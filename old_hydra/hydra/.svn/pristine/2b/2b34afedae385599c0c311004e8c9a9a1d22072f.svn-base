#include "htformulacomposer.h"
#include <TBranch.h>
#include <TGTextEntry.h>

//*-- Author : M. Sanchez
//*-- Modified : 02/11/1999

///////////////////////////////////////////////////////////////////////
//                                                                   //
//                         Formula Composer                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
enum {kCClose=21,kCTextChange};

static char *HTFormulaComposer::fSymbols[]={"(",")","!","%","+","-","==",
					    "&","*","/","!=","|","<=",
					    ">=","&&","<<","<",">","||",">>"};

HTFormulaComposer::HTFormulaComposer(TTree *t,TGTextBuffer *text,
				     const TGWindow *p,
				     const TGWindow *main,
				     Int_t id,UInt_t w, UInt_t h) : 
  TGTransientFrame(p,main,w,h) 
{
  fWidgetId=id;
  fTree=t;
  fWidgets=new TList;
  fText=text;

  initGUI(); 
}

HTFormulaComposer::~HTFormulaComposer(void) {
  fWidgets->Delete();
  delete fWidgets;
  delete fText;
}

void HTFormulaComposer::addSubBranches(TBranch *b,TGListTreeItem *parent) {
  TGListTreeItem *item;
  TBranch *branch=NULL;
  TIter next(b->GetListOfBranches());
  const Text_t *name;
  Text_t *nameEnd;

  while ( (branch=(TBranch *)next())!=NULL) {
    name=branch->GetName();
    nameEnd=name+strlen(name)-1;
    while (*nameEnd!='.' && nameEnd!=name) nameEnd--;
    if (*nameEnd=='.') nameEnd++;
    item=fBranchTree->AddItem(parent,nameEnd,branch);
    item->SetUserData(name);
    addSubBranches(branch,item);
  }  
}

Bool_t HTFormulaComposer::buildBranchesTree(void) {
  TGListTreeItem *item;
  TBranch *branch=NULL;
  TIter next(fTree->GetListOfBranches());

  while ( (branch=(TBranch *)next())!=NULL) {
    item=fBranchTree->AddItem(NULL,branch->GetTitle(),branch);
    item->SetUserData(branch->GetTitle());
    addSubBranches(branch,item);
  }
  return kTRUE;
}

TGCanvas *HTFormulaComposer::buildTreeView(TGFrame *parent) {
  TGCanvas *treeView=new TGCanvas(parent,10,10,kSunkenFrame | kDoubleBorder);

  fBranchTree = new TGListTree(treeView->GetViewPort(), 10, 10, 
	 		       kHorizontalFrame,fgWhitePixel);
  fBranchTree->Associate(this);
  treeView->SetContainer(fBranchTree);
  buildBranchesTree();

  return treeView;
}

TGFrame *HTFormulaComposer::buildOperatorFrame(TGFrame *parent) {
  char *labels[20]={"(", ")", "Not",  "Mod",
		    "+", "-", "==",   "And",
		    "x", "/", "!=",   "Or",
		    "<=",">=","lAnd", "<<",
		    "<", ">", "lOr",  ">>"};
  TGCompositeFrame *opFrame=new TGCompositeFrame(parent,10,10);
  opFrame->SetLayoutManager(new TGMatrixLayout(opFrame,4,5,2));
  TGTextButton *button=0;
  Int_t i;
  TGLayoutHints *lExpandXY=new TGLayoutHints(kLHintsExpandX | kLHintsExpandY);
  fWidgets->Add(lExpandXY);

  for (i=0;i<20;i++) {
    button=new TGTextButton(opFrame,labels[i],i);
    fWidgets->Add(button);
    button->Associate(this);
    button->Resize(30,20);
    opFrame->AddFrame(button,lExpandXY);
  }   

  return opFrame;
}

void HTFormulaComposer::initGUI(void) {
  TGLayoutHints *lExpandXY,*lExpandY,*lo;
  TGVerticalFrame *mainFrame=0,*buttonsFrame=0;
  TGHorizontalFrame *controlFrame=0;
  TGCanvas *treeView=0;
  TGFrame *operatorFrame=0;
  TGTextButton *button=0;

  lExpandXY=new TGLayoutHints(kLHintsExpandX | kLHintsExpandY);
  fWidgets->Add(lExpandXY);
  lExpandY=new TGLayoutHints(kLHintsExpandY);
  fWidgets->Add(lExpandY);

  // Main Frame
  mainFrame=new TGVerticalFrame(this,10,10);
  fWidgets->Add(mainFrame);

  // Control Frame
  controlFrame=new TGHorizontalFrame(mainFrame,10,10);
  fWidgets->Add(controlFrame);

  treeView=buildTreeView(controlFrame);
  fWidgets->Add(treeView);
  controlFrame->AddFrame(treeView,lExpandXY);
  
  buttonsFrame=new TGVerticalFrame(controlFrame,10,10);
  fWidgets->Add(buttonsFrame);

  operatorFrame=buildOperatorFrame(buttonsFrame);
  fWidgets->Add(operatorFrame);
  buttonsFrame->AddFrame(operatorFrame,lExpandY);

  lo=new TGLayoutHints(kLHintsExpandX | kLHintsBottom);
  fWidgets->Add(lo);
  button=new TGTextButton(buttonsFrame,"Close",kCClose);
  button->Associate(this);
  fWidgets->Add(button);
  buttonsFrame->AddFrame(button,lo);

  controlFrame->AddFrame(buttonsFrame,lExpandXY);

  mainFrame->AddFrame(controlFrame,lExpandXY);
  //! Control Frame

  fTextEntry=new TGTextEntry(mainFrame,fText,kCTextChange);
  fTextEntry->Associate(this);
  fWidgets->Add(fTextEntry);
  lo=new TGLayoutHints(kLHintsExpandX);
  fWidgets->Add(lo);
  mainFrame->AddFrame(fTextEntry,lo);

  AddFrame(mainFrame,lExpandXY);
  //! Main Frame

  MapSubwindows();
  SetWindowName("Formula composer");
  Resize(GetDefaultSize());
  MapWindow();
}

void HTFormulaComposer::insertText(Text_t *txt) {
  fTextEntry->InsertText(txt,fTextEntry->GetCursorPosition());
}

Bool_t HTFormulaComposer::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2) {
   // Handle menu and other command generated by the user.

  switch (GET_MSG(msg)) {
    
  case kC_COMMAND:
    switch (GET_SUBMSG(msg)) {
    case kCM_BUTTON:
      if (parm1==kCClose) CloseWindow();
      else if (parm1>=0 && parm1<20) {
	insertText(fSymbols[parm1]);
      }
      break;
    }
    break;
    
  case kC_TEXTENTRY:
    switch (GET_SUBMSG(msg)) {
    case kTE_TEXTCHANGED:
      if (parm1==kCTextChange) 
	SendMessage(fMsgWindow,MK_MSG(kC_TEXTENTRY,kTE_TEXTCHANGED),
		    kUpdateFormula,fWidgetId);
      else if (parm1==kUpdateFormula)
	fClient->NeedRedraw(fTextEntry);
      break;
    }
    break;
  case kC_LISTTREE:
    switch (GET_SUBMSG(msg)) {      
    case kCT_ITEMCLICK:
      if (parm1 == kButton1 || parm1 == kButton2 || parm1 == kButton3) {
	TGListTreeItem *item;
	if ((item = fBranchTree->GetSelected()) != 0 &&
	    item != fSelectedItem) {
	  fBranchTree->HighlightItem(item);
	  fClient->NeedRedraw(fBranchTree);
	  fSelectedItem=item;
	}
      }
      if (parm1 == kButton2) {
	insertText((Text_t *)fSelectedItem->GetUserData());
      }
      break;
    case kCT_ITEMDBLCLICK:
      if (parm1 == kButton1) {
	TGListTreeItem *item;
	if ((item=fBranchTree->GetSelected()) != 0) {
	  fClient->NeedRedraw(fBranchTree);
	  fSelectedItem=item;
	}
      }
      break;
    default:
      break;
    }
    break;
  }
  return kTRUE;
}
