//*-- AUTHOR : Ilse Koenig
//*-- Modified : 28/01/2003 by Ilse Koenig

//////////////////////////////////////////////////////////////////////////////
// HDetParOraIo
//
// Base class for all detector I/O  classes from database Oracle
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////

using namespace std;
#include "horaconn.h"
#include "hdetparoraio.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hparset.h"
#include "hparcond.h"
#include "hparamlist.h"
#include "hdetgeompar.h"
#include "hspecgeompar.h"
#include "hgeomcompositevolume.h"
#include <iostream>
#include <iomanip>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// Include the SQL Communications Area
#include <sqlca.h>
 
ClassImp(HDetParOraIo)
ClassImp(HParOraSet)
ClassImp(HOraGeomObj)

#define NMAX_PARAM 200
#define NMAX_MOD 132
#define NMAX_POINTS 200
#define LOB_BUFSIZE 32512

HParOraSet::HParOraSet(const char* pName) {
  SetName(pName);
  contextId=-1;
  clearVersDate();
}

void HParOraSet::clearVersDate() {
  versDate[0]=-1;
  versDate[1]=1.E+12;
}

HDetParOraIo::HDetParOraIo(HOraConn* pC) : HDetParIo() {
  // constructor gets a pointer to the connection class
  pConn=pC;
  actContVers=0;
  actRunId=-1;
  containerList=0;
}

HDetParOraIo::~HDetParOraIo(void) {
  // destructor
  if (containerList) {
    containerList->Delete();
    delete containerList;
    containerList=0;
  } 
}

void HDetParOraIo::commit(void) {
  // commits all changes
  EXEC SQL COMMIT WORK;
  cout<<"Transaction committed"<<endl;
  return;
}
 

void HDetParOraIo::rollback(void) {
  // discards all changes since last commit 
  EXEC SQL ROLLBACK WORK;
  cout<<"Transaction rolled back"<<endl;
  return;
}


void HDetParOraIo::showSqlError(const char* f) {
  // shows SQL error messages 
  Error(f,"\n%s",sqlca.sqlerrm.sqlerrmc);
}


Int_t HDetParOraIo::getRunStart(HParSet* pPar) {
  // Gets the actual run id from the runtime database and compares it with
  // the last used actRunId for fetching data.
  // If they are different, the run start time (converted to ansi C time) is
  // read from Oracle and stored together with the run id in the data members
  // run_id and runStart
  actRunId=-1;
  Int_t runStart=-1;
  actContVers=(HRun*)gHades->getRuntimeDb()->getCurrentRun();
  if (!actContVers) {
    Error("getRunStart()","current run not set in runtime database");
    return -1;
  }
  const Text_t* refRun=actContVers->getRefRun();
  if (strlen(refRun)>0) sscanf(refRun,"%i",&actRunId); 
  else actRunId=actContVers->getRunId();
  if (pPar) {
    Int_t contVers=getPredefVersion(pPar);
    if (contVers>=0) actRunId=contVers;
  }
  runStart=pConn->getRunStart(actRunId);
  return runStart;
}


const char* HDetParOraIo::getExpLocation() {
  // returns the experiment location
  // (HADES_CAVE: beamtime runs,  VIRTUAL: simulation runs)
  return pConn->getExpLocation();
}


const char* HDetParOraIo::getHistoryDate() {
  // returns the timestamp set by the user to read historic data
  return pConn->getHistoryDate();
}


Int_t HDetParOraIo::getPredefVersion(HParSet* pPar) {
  // finds out if a version for the parameter container has been set by
  // the user (typically by defining a reference run for initialisation
  // in the macro
  // returns -1, if no version found 
  HParVersion* pv=(HParVersion*)actContVers->getParVersion((char*)pPar->GetName());
  if (pv) return pv->getInputVersion(inputNumber);
  else return -1;
}


//*********************************************************************************
//**********  Interface for conditions and standard parameter containers **********
//*********************************************************************************


HParOraSet* HDetParOraIo::getOraSet(HParSet* pPar) {
  if (!containerList) containerList=new TList;
  HParOraSet* pSet=(HParOraSet*)(containerList->FindObject(pPar->GetName()));
  if (!pSet) { 
    pSet=new HParOraSet(pPar->GetName());
    pSet->contextId=getContextId(pPar->IsA()->GetName(),pPar->getParamContext());
    containerList->Add(pSet);
  }
  return pSet;
}

Int_t HDetParOraIo::getContextId(const char* className, const char* paramContext) {
  // return the parameter_context_id
  if (strlen(paramContext)==0) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
     char* p_class;
     char* p_context;
     char* p_exp_loc;
     int context_id=-1;
  EXEC SQL END DECLARE SECTION;
  p_class=(char*)className;
  p_context=(char*)paramContext;
  p_exp_loc=(char*)pConn->getExpLocation();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL SELECT context_id
           INTO :context_id
           FROM hanal.all_param_contexts
           WHERE class = :p_class and context = :p_context
             AND exp_location_id = :p_exp_loc ;
  // cout<<"Id of context "<<paramContext<<": "<<context_id<<endl;
  return context_id;
not_found:
  Error("HDetParOraIo::getContextId","\nContext %s for class %s not found!",
        p_context,p_class);
  return -1;
};

void HDetParOraIo::setChanged(HParSet* pPar) {
  // sets the changed flag, the version (id of actual run) and the comment
  pPar->setChanged();
  pPar->setInputVersion(getActRunId(),inputNumber);
  TString s="Read from Oracle\n             Valid for Run Id ";
  s.Append(Form("%d",getActRunId()));
  s.Append("\n             Status at ");
  s.Append(pConn->getHistoryDate());
  pPar->setDescription(s.Data());    
}

Bool_t HDetParOraIo::readCond(HParCond* pPar, Int_t*) {
  // reads the analysis parameters and fill the container
  Int_t runStart=getRunStart(pPar);
  HParOraSet* pSet=getOraSet(pPar);
  if (pSet->contextId==-1 || runStart==-1) {
    pPar->setInputVersion(-1,inputNumber);
    return kFALSE;
  }    
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (contVers!=-1 && runStart>=pSet->versDate[0] && runStart<=pSet->versDate[1])
    return contVers;
  pSet->clearVersDate();
  EXEC SQL BEGIN DECLARE SECTION;
    int id; 
    struct {
      varchar p_name[NMAX_PARAM][81];
      varchar p_value[NMAX_PARAM][4001];
      varchar p_type[NMAX_PARAM][81];
      int     p_is_binary[NMAX_PARAM]; 
      int     p_is_basic[NMAX_PARAM]; 
      int     p_class_vers[NMAX_PARAM]; 
      int     p_num[NMAX_PARAM];
      double  p_since[NMAX_PARAM];
      double  p_until[NMAX_PARAM];
    } ana;
    struct {
      short p_name_Ind[NMAX_PARAM];
      short p_value_Ind[NMAX_PARAM];
      short p_type_Ind[NMAX_PARAM];
      short p_is_binary_Ind[NMAX_PARAM];
      short p_is_basic_Ind[NMAX_PARAM];
      short p_class_vers_Ind[NMAX_PARAM];
      short p_num_Ind[NMAX_PARAM];
      short p_since_Ind[NMAX_PARAM];
      short p_until_Ind[NMAX_PARAM];
    } ana_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HParSet*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  id=pSet->contextId;
  EXEC SQL SELECT par_name, par_value, par_value_type, is_binary, is_basic_type,
                  class_version, n_values,
                  hdate.to_ansitime(valid_since), hdate.to_ansitime(valid_until)
           INTO :ana INDICATOR :ana_Ind
           FROM hanal.param_values_at_histdate_ext
           WHERE param_context_id = :id
           ORDER BY par_value_id;
  HParamList* paramList = new HParamList;
  TList* blobList=new TList;
  for(Int_t i=0;i<sqlca.sqlerrd[2];i++) {
    if (ana_Ind.p_name_Ind[i]!=-1 && ana_Ind.p_value_Ind[i]!=-1) {
      ana.p_name[i].arr[ana.p_name[i].len]='\0';    
      ana.p_value[i].arr[ana.p_value[i].len]='\0';
      ana.p_type[i].arr[ana.p_type[i].len]='\0';
      if (ana.p_since[i]>pSet->versDate[0]) pSet->versDate[0]=ana.p_since[i];
      if (ana.p_until[i]<pSet->versDate[1] || pSet->versDate[1]<0)
        pSet->versDate[1]=ana.p_until[i];
      if (ana.p_is_binary[i]==0)
        paramList->add((char*)(ana.p_name[i].arr),(char*)(ana.p_value[i].arr),
                       ana.p_type[i].arr[0],ana.p_num[i]);
      else {
        HParamBinObj* o=new HParamBinObj;
        o->SetName((char*)(ana.p_name[i].arr));
        o->setParamType((char*)(ana.p_type[i].arr));
        if (ana.p_is_basic[i]==0) o->setClassVersion(ana.p_class_vers[i]);
        paramList->getBinaryList()->Add(o);
        Int_t lobId;
        sscanf((char*)(ana.p_value[i].arr),"%i",&lobId);
        HParOraBlob* ob=new HParOraBlob(o,lobId);
        blobList->Add(ob);
      }
    }
  }
  TIter next(blobList);
  HParOraBlob* b;
  Bool_t rc=kTRUE;
  while ((b=(HParOraBlob*)next())!=0 && rc) {
    rc=readBlob(b->binaryParam,b->blobId);
  }    
  if (rc && sqlca.sqlerrd[2]>0) rc=pPar->getParams(paramList);
  else pPar->setInputVersion(-1,inputNumber);
  blobList->Delete();
  delete blobList;  
  delete paramList;
  if (rc==kTRUE) {
    setChanged(pPar);
    cout<<pPar->GetName()<<" initialized from Oracle"<<'\n';
  }
  return rc;
}

Bool_t HDetParOraIo::readBlob(HParamBinObj* obj,Int_t lobId) {
  EXEC SQL BEGIN DECLARE SECTION;
    int            id;
    unsigned int   loblength;
    unsigned int   amount;
    unsigned int   offset;
    unsigned char  buffer[LOB_BUFSIZE];
    EXEC SQL VAR buffer IS RAW(LOB_BUFSIZE);
  EXEC SQL END DECLARE SECTION;
  id=lobId;
  amount=LOB_BUFSIZE;
  UChar_t* paramValue=0;
  UInt_t amountRead=0;
  EXEC SQL WHENEVER SQLERROR GOTO notfound;
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;
  EXEC SQL EXECUTE
    BEGIN
      hanal.hap_param_lob_access.read_blob(:id,:amount,:loblength,:buffer);
    END;
  END-EXEC;
  obj->setLength(loblength);
  paramValue=obj->getParamValue();
  amountRead=amount;
  memcpy((unsigned char*)paramValue,buffer,amount);
  while (amountRead<loblength) {
    amount= (loblength>LOB_BUFSIZE) ? LOB_BUFSIZE : loblength ;
    offset=amountRead+1;
    EXEC SQL EXECUTE
      BEGIN
        hanal.hap_param_lob_access.read_next_buffer(:amount,:offset,:buffer);
      END;
    END-EXEC;
    memcpy((unsigned char*)(&paramValue[amountRead]),buffer,amount);
    amountRead+=amount;
  }
  return kTRUE;
notfound:
  showSqlError("readBlob");
  Error("readBlob","Blob %i not read",lobId);
  return kFALSE;
}

Int_t HDetParOraIo::createParamVers(HParCond* pPar) {
  // create analysis parameter version in Oracle
  // returns version number or -1 if error occurred
  EXEC SQL BEGIN DECLARE SECTION;
     char* p_class;
     char* p_author;
     char* p_descript;
     char* p_context;
     char* p_exp_loc;
     int vers=-1;
     int context_id=-1;
  EXEC SQL END DECLARE SECTION;
  p_class=(char*)(pPar->IsA()->GetName());
  p_author=(char*)(pPar->getAuthor());
  p_descript=(char*)(pPar->getDescription());
  p_context=(char*)(pPar->getParamContext());
  p_exp_loc=(char*)(pConn->getExpLocation());
  if (strlen(p_author)==0) {
    Error("createParamVers(...)",
          "author of parameters not defined");
    return -1;
  }
  if (strlen(p_descript)==0) {
    Error("createParamVers(...)",
          "description of parameters not defined");
    return -1;
  }
  if (strlen(p_context)==0) {
    Error("createParamVers(...)",
          "Purpose of parameters not defined");
    return -1;
  }
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL EXECUTE
    DECLARE
    BEGIN
      :context_id := hanal.hap_param_query.get_context_id(
                         :p_class,:p_context,:p_exp_loc);
      IF :context_id > 0 THEN
        :vers := hanal.hap_param_query.next_param_vers_load(:p_class);
        IF :vers > 0 THEN
          INSERT INTO hanal.param_vers_load
            (param_vers_load_id,param_context_id,author,description)
            VALUES (:vers,:context_id,:p_author,:p_descript);
        END IF;
      END IF;
    END;
  END-EXEC;
  return vers;
not_found:
  showSqlError("createParamVers(const char*)");
  rollback();
  return vers;    
};

Int_t HDetParOraIo::writeCond(HParCond* pPar) {
  // write analysis parameters to Oracle
  Int_t runStart=getRunStart();
  if (runStart==-1) {
    pPar->setChanged(kFALSE);
    return -1;
  }    
  cout<<"---------------  Storage of "<<pPar->GetName()<<"  ---------------\n";
  Int_t version=createParamVers(pPar);
  if (version==-1) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int vers[NMAX_PARAM];
    char p_name[NMAX_PARAM][81];
    char p_value[NMAX_PARAM][4000];
    char p_type[NMAX_PARAM][81];
    int  p_is_binary[NMAX_PARAM];
    int  p_is_basic[NMAX_PARAM];
    int p_nvalues[NMAX_PARAM];
    int p_num[NMAX_PARAM];
    int p_class_vers [NMAX_PARAM];
    short class_vers_Ind [NMAX_PARAM];
    int rows_to_insert;
  EXEC SQL END DECLARE SECTION;
  HParamList* paramList = new HParamList;
  pPar->putParams(paramList);
  TList* pList=paramList->getList();
  TIter next(pList);
  HParamObj* po;
  TList* pBinList=paramList->getBinaryList();
  TIter nextBin(pBinList);
  HParamBinObj* pbo;
  Int_t n=0, m=0;
  while ((po=(HParamObj*)next())) {
    vers[n]=version;
    strcpy(p_name[n],po->GetName());
    strcpy(p_value[n],po->getParamValue());
    p_type[n][0]=po->getParamType();
    p_type[n][1]='\0';
    p_is_binary[n]=0;
    p_is_basic[n]=1;
    p_nvalues[n]=po->getNumParams();
    p_num[n]=n+1;
    n++;
  }
  rows_to_insert=n;
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL FOR :rows_to_insert
    INSERT INTO hanal.param_value_load
      ( param_vers_load_id,param_name,param_value,param_value_type,
        is_binary,is_basic_type,nvalues,param_num)
      VALUES(:vers,:p_name,:p_value,:p_type,:p_is_binary,:p_is_basic,
        :p_nvalues,:p_num);
  cout<<"****************************************************************\n";
  cout<<"***  "<<pPar->GetName()<<" written to Oracle"<<endl;
  cout<<"***  Version:                     "<<version<<endl;
  cout<<"***  Number of parameters:        "<<rows_to_insert<<endl;
  m=n;
  n=0;
  while ((pbo=(HParamBinObj*)nextBin())) {
    vers[n]=version;
    strcpy(p_name[n],pbo->GetName());
    strcpy(p_type[n],pbo->getParamType());
    p_is_binary[n]=1;
    if (pbo->isBasicType()) {
      p_is_basic[n]=1;
      class_vers_Ind[n]=-1;
    } else {
      p_is_basic[n]=0;
      p_class_vers[n]=pbo->getClassVersion();
      class_vers_Ind[n]=0;
      p_nvalues[n]=0;
    }
    p_nvalues[n]=pbo->getNumParams();
    sprintf(p_value[n],"%i",storeBlob(pbo->getParamValue(),pbo->getLength()));
    p_num[n]=m+n+1;
    n++;
  }
  if (n>0) {
    rows_to_insert=n;
    EXEC SQL FOR :rows_to_insert
      INSERT INTO hanal.param_value_load
          (param_vers_load_id,param_name,param_value,param_value_type,
           is_binary,is_basic_type,nvalues,param_num,class_version)
        VALUES(:vers,:p_name,:p_value,:p_type,:p_is_binary,:p_is_basic,
               :p_nvalues,:p_num,:p_class_vers:class_vers_Ind);
    cout<<"***  Number of binary parameters: "<<rows_to_insert<<endl;
  }
  cout<<"****************************************************************\n";
  commit();
  pPar->setChanged(kFALSE);
  delete paramList;
  return version;
not_found:
  showSqlError("writeCond(HParCond*)");
  rollback();
  pPar->setChanged(kFALSE);
  delete paramList;
  return -1;
}

Int_t HDetParOraIo::storeBlob(UChar_t* pValue, Int_t pLength) {
  EXEC SQL BEGIN DECLARE SECTION;
    unsigned char buffer[LOB_BUFSIZE];
    int           totlen;
    int           amount;
    int           offset;
    int           id;
    EXEC SQL VAR buffer IS RAW(LOB_BUFSIZE);
  EXEC SQL END DECLARE SECTION;
  offset=1;
  totlen=pLength;
  amount= (totlen>LOB_BUFSIZE) ? LOB_BUFSIZE : totlen;
  memcpy(buffer,pValue,amount);
  id=-1;
  Int_t restlen=totlen-amount;
  EXEC SQL WHENEVER SQLERROR GOTO errorfound;
  EXEC SQL WHENEVER NOT FOUND GOTO errorfound;
  EXEC SQL EXECUTE
    DECLARE
    BEGIN
      hanal.hap_param_lob_access.add_blob(:totlen,:amount,:buffer,:id);
    END;
  END-EXEC;
  while (restlen>0) {
    offset+=LOB_BUFSIZE;
    amount= (restlen>LOB_BUFSIZE) ? LOB_BUFSIZE : restlen;
    memcpy(buffer,&pValue[offset-1],amount);
    EXEC SQL EXECUTE
      DECLARE
      BEGIN
        hanal.hap_param_lob_access.append_to_blob(:id,:amount,:offset,:buffer);
      END;
    END-EXEC;
    restlen-=amount;
  }
  return id;
errorfound:
  showSqlError("storeBlob");
  EXEC SQL ROLLBACK WORK;
  cout<<"Blob not stored."<<endl;
  return -1;
}

//*********************************************************************************
//**********  Interface for geometry and alignment  *******************************
//*********************************************************************************

Int_t HDetParOraIo::getIdealGeomVersion() {
  return pConn->getIdealGeomVersion();
}

Int_t HDetParOraIo::readGeomVersion(HDetGeomPar* pPar,Int_t& geomVers,Int_t& alignmentVers,
                                    Bool_t includeAlignment) {
  // reads the geometry version of the ideal geometry
  // takes the latest version as a temporal solution as long as the geometry
  // tables have to version management based on the date
  // reads eventually the version for the alignment
  Int_t runStart=getRunStart(pPar);
  if (runStart==-1) return -1;
  if (geomVers<=0) {
    geomVers=pConn->getIdealGeomVersion();
    if (geomVers==-1) return -1;
  }
  HParOraSet* oraSet=0;
  Int_t contextId=-1;
  if (!containerList) containerList=new TList;
  else oraSet=(HParOraSet*)(containerList->FindObject(pPar->GetName()));
  if (!oraSet) { 
    oraSet=new HParOraSet(pPar->GetName());
    if (strcmp(pConn->getExpLocation(),"VIRTUAL")!=0 && includeAlignment) {
      contextId=getContextId("HDetGeomPar",pPar->getParamContext());
      if (contextId==-1) return -1;
      oraSet->contextId=contextId;
    }
    containerList->Add(oraSet);
  }
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (contVers>0 && runStart>=oraSet->versDate[0] && runStart<=oraSet->versDate[1])
    return contVers;
  if (!(strcmp(pConn->getExpLocation(),"VIRTUAL")==0) && includeAlignment) {
    EXEC SQL BEGIN DECLARE SECTION;
      int    context;
      char*  det;
      int    vers=-1;
      double since;
      double until;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL WHENEVER SQLERROR DO showSqlError("readGeomVersion(HParSet*)");
    EXEC SQL WHENEVER NOT FOUND GOTO notfound;
    context=(int)oraSet->contextId;
    det=(char*)pPar->getDetectorName();
    EXEC SQL SELECT version,
                    hdate.to_ansitime(valid_since),
                    hdate.to_ansitime(valid_until)
             INTO :vers, :since, :until
             FROM hanal.alignment_vers_at_date
             WHERE detector_name = upper(:det) and context_id = :context;
    alignmentVers=vers;
    oraSet->versDate[0]=since;
    oraSet->versDate[1]=until;
  } else {
    alignmentVers=-1;
    oraSet->versDate[0]=0;  // year 1970
    oraSet->versDate[1]=1.E+12;
  }
  return getActRunId();
notfound:
  alignmentVers=0;
  Double_t oldUntil=oraSet->versDate[1];
  oraSet->versDate[0]=-1;
  oraSet->versDate[1]=-1;
  if (contVers==-1 || oldUntil!=-1) return getActRunId();
  else return contVers;
}


Bool_t HDetParOraIo::readGeometry(HDetGeomPar* pPar,Int_t* set,Int_t contGeomVers,
                                  Bool_t includeAlignment) {
  // reads the geometry of a detector and eventually the alignment
  // this function is called by the derived classes after the read of
  //   the unique names of the modules and components 
  Int_t contVers=pPar->getInputVersion(inputNumber);
  Int_t geomVers=contGeomVers;
  Int_t alignmentVers=0;
  Int_t version=readGeomVersion(pPar,geomVers,alignmentVers,includeAlignment);
  // cout<<"contVers:"<<contVers<<"   version: "<<version<<"  alignmentVers: "<<alignmentVers<<endl;
  if (version==-1) {
    pPar->clear();
    return kFALSE;
  }
  if (contVers==version) return kTRUE;
  Bool_t allFound=kTRUE;
  TList geomObjects;
  for(Int_t pos=0;pos<pPar->getNumModules();pos++) {
    HModGeomPar* pMod=pPar->getModule(pos);
    if (pMod && set[pos])
      geomObjects.Add(new HOraGeomObj(pMod->GetName(),pMod,'M',0,1));
  }
  if (pPar->isFirstInitialization()) {
    for(Int_t i=0;i<pPar->getNumRefModules();i++) {
      HGeomCompositeVolume* refMod=pPar->getRefVolume(i);
      if (refMod && refMod->getNumPoints()==0) {
        geomObjects.Add(new HOraGeomObj(refMod->GetName(),refMod,'R',0,1));
        for(Int_t l=0;l<refMod->getNumComponents();l++) {
          HGeomVolume* comp=refMod->getComponent(l);
          geomObjects.Add(new HOraGeomObj(comp->GetName(),comp,'C',refMod,1));
        }
      }
    }
    if (!readIdealGeomTransform(&geomObjects,geomVers)
        || !readGeomPoints(&geomObjects,geomVers)) allFound=kFALSE;
  } else {
    if (!readIdealGeomTransform(&geomObjects,geomVers)) allFound=kFALSE;
  }
  if (allFound) cout<<pPar->GetName()<<": Ideal geometry initialized from Oracle\n";
  if (strcmp(pConn->getExpLocation(),"VIRTUAL")!=0 && alignmentVers>0) {
    Int_t n=readAlignmentTransform(&geomObjects,alignmentVers);
    if (n>0) cout<<pPar->GetName()<<": Alignment for "<<n<<" modules read from Oracle\n";
  }
  if (allFound) {
    pPar->setInputVersion(version,inputNumber);
    pPar->setChanged();
    pPar->setNotFirstInit();
  } else pPar->clear();
  return allFound;
}

Bool_t HDetParOraIo::readIdealGeomTransform(TList* geomObjects,Int_t geomVers) {
  // reads the ideal geometry transformation of all volume
  EXEC SQL BEGIN DECLARE SECTION;
    char* oName;
    int oType;
    int vers;
    struct {
      int id;
      double t1;
      double t2;
      double t3;
      double r11;
      double r12;
      double r13;
      double r21;
      double r22;
      double r23;
      double r31;
      double r32;
      double r33;
    } tr;
    struct {
      short id_Ind;
      short t1_Ind;
      short t2_Ind;
      short t3_Ind;
      short r11_Ind;
      short r12_Ind;
      short r13_Ind;
      short r21_Ind;
      short r22_Ind;
      short r23_Ind;
      short r31_Ind;
      short r32_Ind;
      short r33_Ind;
    } tr_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readGeomTransform(TList*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE trans_cursor CURSOR FOR
    SELECT o.obj_index,
           trans_t1, trans_t2, trans_t3,
           trans_r11, trans_r12, trans_r13,
           trans_r21,trans_r22,trans_r23,
           trans_r31,trans_r32,trans_r33
    FROM hades_geom.geom_objects o, hades_geom.geom_transformations t
    WHERE obj_name_short = :oName AND obj_type = :oType
      AND t.obj_index = o.obj_index
      AND vers_index = ( SELECT MAX(vers_index)
                         FROM hades_geom.geom_transformations
                         WHERE obj_index = o.obj_index
                           AND vers_index <= :vers );
  vers=(int)geomVers;
  TIter next(geomObjects);
  HOraGeomObj* o;
  Double_t t[3];
  Double_t r[9];
  Bool_t allFound=kTRUE;
  while ((o=(HOraGeomObj*)next())) {
    oName=(char*)(o->GetName());
    oType=(int)o->objType;
    EXEC SQL OPEN trans_cursor;
    EXEC SQL FETCH trans_cursor INTO :tr INDICATOR :tr_Ind;
    if (tr_Ind.id_Ind==-1) allFound=kFALSE; 
    else {
      o->objId=tr.id;
      t[0]=tr.t1;
      t[1]=tr.t2;
      t[2]=tr.t3;
      r[0]=tr.r11;
      r[1]=tr.r12;
      r[2]=tr.r13;
      r[3]=tr.r21;
      r[4]=tr.r22;
      r[5]=tr.r23;
      r[6]=tr.r31;
      r[7]=tr.r32;
      r[8]=tr.r33;
      if (o->volType=='M') {
        HModGeomPar* pMod=(HModGeomPar*)(o->pObj);
        HGeomTransform& tp=pMod->getLabTransform();
        tp.setTransVector(t);
        tp.setRotMatrix(r);
      } else {
        HGeomVolume* vol=(HGeomVolume*)(o->pObj);
        HGeomTransform& tp=vol->getTransform();
        tp.setTransVector(t);
        tp.setRotMatrix(r);
        if (o->refObj) {
          vol->setMother(o->refObj->GetName());
          HGeomTransform& tm=((HGeomVolume*)(o->refObj))->getTransform();
          tp.transTo(tm);
        } else vol->setMother("CAVE");
      }
    }
  }
  EXEC SQL CLOSE trans_cursor;
  return allFound;
}

Bool_t HDetParOraIo::readGeomPoints(TList* geomObjects,Int_t geomVers) {
  // reads the shapes and points for all reference modules and inner components
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int vers;   
    varchar shape[8];
    short shape_Ind=-1;
    struct {
      double x[NMAX_POINTS];
      double y[NMAX_POINTS];
      double z[NMAX_POINTS];
      int c[NMAX_POINTS];
    } p3d;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readGeomPoints(TList*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE shape_cursor CURSOR FOR
    SELECT UPPER(Geant_shape)
    FROM hades_geom.geom_properties
    WHERE obj_index = :id
      AND vers_index = ( SELECT MAX(vers_index)
                         FROM hades_geom.geom_properties
                         WHERE obj_index = :id AND vers_index <= :vers );
  EXEC SQL DECLARE point_cursor CURSOR FOR
    SELECT ROUND(p3d_x,3), ROUND(p3d_y,3), ROUND(p3d_z,3), p3d_corner
    FROM hades_geom.geom_3dpoints
    WHERE obj_index = :id
    AND vers_index = ( SELECT MAX(vers_index)
                       FROM hades_geom.geom_3dpoints
                       WHERE obj_index = :id AND vers_index <= :vers )
    ORDER BY p3d_corner;
  vers=(int)geomVers;
  TIter next(geomObjects);
  HOraGeomObj* o;
  Bool_t allFound=kTRUE;
  while ((o=(HOraGeomObj*)next())) {
    if (o->volType!='M' && (id=(int)o->objId)!=-1) {
      HGeomVolume* vol=(HGeomVolume*)(o->pObj);
      EXEC SQL OPEN shape_cursor;
      EXEC SQL OPEN point_cursor;
      EXEC SQL FETCH shape_cursor INTO :shape INDICATOR :shape_Ind;
      EXEC SQL FETCH point_cursor INTO :p3d;
      if (shape_Ind==-1) allFound=kFALSE;
      else {
        if (shape.len==3) shape.arr[3]=' ';
        shape.arr[4]='\0';
        vol->setShape(((char*)(shape.arr)));
      }
      Int_t nPoints=sqlca.sqlerrd[2];
      if (nPoints<=0) allFound=kFALSE;
      else {
        if (strcmp(vol->getShape(),"PGON")==0 || strcmp(vol->getShape(),"PCON")==0) {
          vol->createPoints(nPoints+1);
          vol->setPoint(0,nPoints-1);
          for(int i=0;i<nPoints;i++) {
            vol->setPoint((p3d.c[i]),p3d.x[i],p3d.y[i],p3d.z[i]);
          }
        } else {
          vol->createPoints(nPoints);
          for(int i=0;i<nPoints;i++) {
            vol->setPoint((p3d.c[i]-1),p3d.x[i],p3d.y[i],p3d.z[i]);
          }
        }
      }
    }
  }
  EXEC SQL CLOSE shape_cursor;
  EXEC SQL CLOSE point_cursor;
  return allFound;
}

Int_t HDetParOraIo::readAlignmentTransform(TList* geomObjects,Int_t version) {
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int vers;
    struct {
      double r11;
      double r12;
      double r13;
      double r21;
      double r22;
      double r23;
      double r31;
      double r32;
      double r33;
      double t1;
      double t2;
      double t3;
    } tr;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readGeomPoints(TList*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE align_cursor CURSOR FOR
    SELECT r11, r12, r13, r21, r22, r23, r31, r32, r33,
           px, py, pz
    FROM hanal.alignment_data
    WHERE geom_obj_id = :id and vers_id = :vers;
  vers=(int)version;
  TIter next(geomObjects);
  HOraGeomObj* o;
  Double_t r[9];
  Double_t t[3];
  Int_t n=0;
  while ((o=(HOraGeomObj*)next())) {
    if (o->volType=='M' && (id=(int)o->objId)!=-1) {
      EXEC SQL OPEN align_cursor;
      EXEC SQL FETCH align_cursor INTO :tr;
      if (sqlca.sqlerrd[2]==1) {
        r[0]=tr.r11;
        r[1]=tr.r12;
        r[2]=tr.r13;
        r[3]=tr.r21;
        r[4]=tr.r22;
        r[5]=tr.r23;
        r[6]=tr.r31;
        r[7]=tr.r32;
        r[8]=tr.r33;
        t[0]=tr.t1;
        t[1]=tr.t2;
        t[2]=tr.t3;
        HModGeomPar* pMod=(HModGeomPar*)(o->pObj);
        HGeomTransform& tp=pMod->getLabTransform();
        tp.setTransVector(t);
        tp.setRotMatrix(r);
        n++;
      }
    }
  }
  EXEC SQL CLOSE align_cursor;
  return n;
}


Int_t HDetParOraIo:: writeAlignment(HDetGeomPar* pPar) {
  Int_t version=getAlignmentOutputVersion(pPar,pPar->getParamContext());
  if (version==-1) return -1;
  Int_t n=0;
  Bool_t rc=kTRUE;
  for(Int_t i=0;i<pPar->getNumModules();i++) {
    HModGeomPar* pMod=pPar->getModule(i);
    if (!pMod) continue;
    if ((rc=writeTransform(version,pMod->GetName(),1,pMod->getLabTransform()))) n++;
    else break;
  }
  if (rc && n>0) {
    cout<<pPar->GetName()<<" alignment:  "<<n<<" rows inserted\n";
    commit();
  }
  pPar->setChanged(kFALSE);
  return version;
}


Int_t HDetParOraIo::getAlignmentOutputVersion(HParSet* pPar,const char* context) {
  // gets the alignment output version for the actual run
  // creates a new one, if the version is -1
  Int_t version=pConn->getAlignmentOutputVersion();
  if (version==-1) {
    Int_t contextId=getContextId("HDetGeomPar",context);
    version=createAlignmentVers(pPar,contextId);
    pConn->setAlignmentOutputVersion(version);
  }
  return version;
}


Int_t HDetParOraIo::createAlignmentVers(HParSet* pPar,Int_t geomContext) {
  // creates a new version for the alignment parameters
  // returns the new version
  if (geomContext==-1) return -1;
  cout<<"---------------  Storage of alignment  ---------------\n";
  if (strcmp(getExpLocation(),"VIRTUAL")==0) {
    Error("createVers(HParSet*)",
          "No alignment for simulation runs");
    return -1;
  }
  if (strlen(pPar->getAuthor())==0) {
    Error("createVers(HParSet*)",
          "author of parameters not defined");
    return -1;
  }
  if (strlen(pPar->getDescription())==0) {
    Error("createVers(HParSet*)",
          "descriction of parameters not defined");
    return -1;
  }
  EXEC SQL BEGIN DECLARE SECTION;
    int   vers=-1;
    int   context;
    int   run;
    char* creator;
    char* descript;
  EXEC SQL END DECLARE SECTION;
  context=geomContext;
  run=getActRunId();
  creator=(char*)pPar->getAuthor();
  descript=(char*)pPar->getDescription();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL EXECUTE
    BEGIN
      SELECT hanal.ana_par_query.next_version INTO :vers FROM DUAL;
      INSERT INTO hanal.alignment_vers
                 (vers_id, orig_context_id, run_id, author, description)
          VALUES (:vers, :context, :run, :creator, :descript);
    END;
  END-EXEC;
  cout<<"Oracle version for aligment parameters created:  "<<vers<<endl;
  return vers;
not_found:
  showSqlError("createVers(HParSet*)");
  rollback();
  return vers;
}


Bool_t HDetParOraIo:: writeTransform(Int_t version, const char* name, Int_t geomObjType,
                                     const HGeomTransform& transform) {
  EXEC SQL BEGIN DECLARE SECTION;
    int    vers;
    char   oname[9];
    int    otype;
    double r11;
    double r12;
    double r13;
    double r21;
    double r22;
    double r23;
    double r31;
    double r32;
    double r33;
    double p1;
    double p2;
    double p3;
  EXEC SQL END DECLARE SECTION;
  vers=(int)version;
  strcpy(oname,name);
  otype=geomObjType;
  const HGeomRotation tr=transform.getRotMatrix();
  r11=(double)tr(0);
  r12=(double)tr(1);
  r13=(double)tr(2);
  r21=(double)tr(3);
  r22=(double)tr(4);
  r23=(double)tr(5);
  r31=(double)tr(6);
  r32=(double)tr(7);
  r33=(double)tr(8);
  const HGeomVector tv=transform.getTransVector();
  p1=(double)tv(0);
  p2=(double)tv(1);
  p3=(double)tv(2);
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL INSERT INTO hanal.alignment_data (
                   geom_obj_id, vers_id,
                   r11,r12,r13,r21,r22,r23,r31,r32,r33,
                   px,py,pz)
           VALUES (hanal.ana_par_query.geom_obj_id(:oname,:otype),:vers,
                   round(:r11,6),round(:r12,6),round(:r13,6),
                   round(:r21,6),round(:r22,6),round(:r23,6),
                   round(:r31,6),round(:r32,6),round(:r33,6),
                   round(:p1,3),round(:p2,3),round(:p3,3));
  return kTRUE;
not_found:
  showSqlError("writeTransform(...)");
  rollback();
  return kFALSE;
}
