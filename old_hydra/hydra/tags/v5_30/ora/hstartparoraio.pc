//*-- AUTHOR : Ilse Koenig
//*-- Modified : 12/02/2001 by I. Koenig
//*-- Created : 28/09/2000 by I. Koenig

//////////////////////////////////////////////////////////////////////////////
// HStartParOraIo
//
// Interface class to database Oracle for input/output of parameters needed
// by the START detector
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////

#include "hstartparoraio.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hspectrometer.h"
#include "hdetector.h"
#include "hstartdetector.h"
#include "hstartcalpar.h"
#include "hstartlookup.h"
#include "hstartgeompar.h"
#include "hgeomcompositevolume.h"
#include <iostream.h>
#include <unistd.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// SQL Communications Area
#include <sqlca.h>

ClassImp(HStartParOraIo)

#define START_MAXMODS 10
#define START_MAXSTRIPS 100

HStartParOraIo::HStartParOraIo(HOraConn* pC) : HDetParOraIo(pC) {
  // constructor
  // sets the name of the I/O class "HStartParIo"
  // gets the pointer to the connection class
  fName="HStartParIo";
  pVersId=-1;
  initModules=new TArrayI(START_MAXMODS);
  startIds=0;
  calparDate=0;
  lookupDate=0;
  calparVersions=0;
  resetComments();
}


HStartParOraIo::~HStartParOraIo() {
  // destructor
  if (initModules) delete initModules;
  if (startIds) delete startIds;
  if (calparDate) delete [] calparDate;
  if (calparVersions) delete calparVersions;
}


Bool_t HStartParOraIo::init(HParSet* pPar,Int_t* set) {
  // calls special read-function for each parameter container
  if (startIo()==-1) return kFALSE; // no modules found
  const Text_t* name=pPar->GetName();
  if (strcmp(name,"StartCalPar")==0) return read(((HStartCalPar*)pPar),set);
  if (strcmp(name,"StartLookup")==0) return read(((HStartLookup*)pPar),set);
  if (strcmp(name,"StartGeomPar")==0) return read(((HStartGeomPar*)pPar),set);
  cout<<"initialization of "<<name<<" not possible from Oracle!"<<endl;
  return kFALSE;
}

Int_t HStartParOraIo::write(HParSet* pPar) {
  // calls the appropriate write function for the container
  if (startIo()==-1) return 0; // no modules found
  const Text_t* name=pPar->GetName();
  if (!strcmp(name,"StartCalPar"))
     return writePar((HStartCalPar*)pPar);
  return 0;
}


Int_t HStartParOraIo::startIo(void) {
  if ((runStart=getRunStart())==-1) return -1;
  if (startIds==0) {
    startIds=new TArrayI(START_MAXMODS);
    readIds();
  }
  return pVersId;  // is -1 if no modules found
}


Int_t HStartParOraIo::readIds() {
  // reads the number of strips of all modules defined for the actual run
  //   and stores them in array startIds (the position in the array is
  //   identical with the module position in the setup (0: START 1: VETO) 
  // returns the run id if at least one module can be found
  // returns -1 if nothing is found
  HStartDetector* det=(HStartDetector*)(gHades->getSetup()->getDetector("Start"));
  maxModules=det->getMaxModules();
  maxStrips=det->getMaxComponents();
  if (maxModules>START_MAXMODS || START_MAXSTRIPS < (maxModules*maxStrips)) {
    Error("HStartParOraIo::readIds()",
          "Maximum i/o buffer sizes to small:\n maximum number of modules: %i\n"
          "maximum number of strips: %i",
          START_MAXMODS,START_MAXSTRIPS);
    return -1;
  }
  for(Int_t i=0;i<START_MAXMODS;i++) startIds->AddAt(0,i);
  pVersId=-1;
  EXEC SQL BEGIN DECLARE SECTION;
  struct {
    int pos[START_MAXMODS];
    int nstrips[START_MAXMODS];
  } mods;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readIds()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_pos, n_strips
           INTO :mods
           FROM start_ana.det_setup_at_date;
  Int_t nMods=sqlca.sqlerrd[2]; // number of rows returned by select
  for(Int_t i=0;i<nMods;i++) {
    if (det->getModule(-1,mods.pos[i])) {
      startIds->AddAt(mods.nstrips[i],mods.pos[i]);
      if (mods.nstrips[i]!=maxStrips)
      Error("HStartParOraIo::readIds()",
            "number of strips in HStartDetector:    %i\n"
            "number of strips in Oracle at position %i: %i",
            maxStrips,mods.pos[i],mods.nstrips[i]);
    }
  }
  if (nMods>0) pVersId=getActRunId();
  // printNStrips();
  return pVersId;
}


void HStartParOraIo::printNStrips() {
  // prints the number of strips of all modules for the current setup
  // found in the database
  if (startIds) {
    cout<<"START detector modules: ";
    for(Int_t i=0;i<maxModules;i++) cout<<"   "<<i<<": "<<startIds->At(i);
    cout<<'\n';
  }
}


Int_t HStartParOraIo::getCalparVersion(Int_t version) {
  // reads the newest version number for the calibration parameters
  // valid for the current event file
  if (!calparVersions) {
    calparVersions=new TArrayI(startIds->GetSize());
    for(Int_t i=0;i<calparVersions->GetSize();i++) calparVersions->AddAt(-1,i);
  }
  if (calparDate) {
     if (version!=-1 && runStart>=calparDate[0] && runStart<=calparDate[1])
      return version;
  }
  else calparDate=new Double_t[2];
  clearVersDate(calparDate);
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int pos[START_MAXMODS];
      int vers[START_MAXMODS];
      double since[START_MAXMODS];
      double until[START_MAXMODS];
    } cal;
    struct {
      short pos[START_MAXMODS];
      short vers[START_MAXMODS];
      short since[START_MAXMODS];
      short until[START_MAXMODS];
    } cal_Ind;
  EXEC SQL END DECLARE SECTION;
  Int_t nMods=0;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getCalparVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_pos, version, hdate.to_ansitime(valid_since),
                                hdate.to_ansitime(valid_until)
           INTO :cal INDICATOR :cal_Ind
           FROM start_ana.cal_vers_at_run;
  nMods=sqlca.sqlerrd[2];
  for(Int_t i=0;i<nMods;i++) {
    for(Int_t j=0;j<startIds->GetSize();j++) {
      if (startIds->At(j)>0 && j==cal.pos[i]) {
        calparVersions->AddAt(cal.vers[i],j);
        calparDate[0]=(cal.since[i]>calparDate[0]) ? cal.since[i]
                                                        : calparDate[0];
        calparDate[1]=(cal.until[i]<calparDate[1]) ? cal.until[i]
                                                        : calparDate[1];
      }
    }
  }
  // cout<<"version range: "<<calparDate[0]<<" - "<<calparDate[1]<<endl;
  if (calparDate[0]>0) return getActRunId();
  return -1;
};


Bool_t HStartParOraIo::read(HStartCalPar* pPar, Int_t* set) {
  // reads the calibration parameters and fill the StartCalPar container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getCalparVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int modPos[START_MAXSTRIPS];
      int strip[START_MAXSTRIPS];
      float slo[START_MAXSTRIPS];
      float ofs[START_MAXSTRIPS];
    } cal;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HStartCalPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_pos, strip, slope, offset
           INTO :cal
           FROM start_ana.cal_par_at_run;
  initModules->Reset();
  Int_t nCal=sqlca.sqlerrd[2];
  Int_t m;
  for(Int_t i=0;i<nCal;i++) {
    m=cal.modPos[i];
    if (set[m]) {
      HStartCalParChan& chan=(*pPar)[m][cal.strip[i]];
      chan.fill(cal.slo[i],cal.ofs[i]);
      initModules->AddAt(m+1,m);
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<maxModules;i++) {
    if (set[i]>0) {
      if (initModules->At(i)>0) set[i]=0;
      else allFound=kFALSE;
    }
  }
  pPar->setChanged();
  printInfo("StartCalPar: module(s) initialized from Oracle: ");
  return allFound;
};

  
Int_t HStartParOraIo::getLookupVersion(Int_t vers) {
  // reads the version for the StartLookup container valid at the start time
  // of the actual run
  // if the version differs from the container version changes, the container
  // must be reinitialized
  if (!lookupDate) {
    lookupDate=new Double_t[2];
    clearVersDate(lookupDate);
  }
  Double_t dateRange[2];
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      double c_since;
      double c_until;
      double r_since;
      double r_until;
    } lvrec;
    struct {
      short c_since_ind;
      short c_until_ind;
      short r_since_ind;
      short r_until_ind;
    } lvrec_ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getLookupVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;
  EXEC SQL SELECT hdate.to_ansitime(config_since), 
                  hdate.to_ansitime(config_until),
                  hdate.to_ansitime(dc_since),
                  hdate.to_ansitime(dc_until)
    INTO :lvrec INDICATOR :lvrec_ind
    FROM tof_ana.start_lookup_time_range;
  if (lvrec.c_since!=-1) dateRange[0]=lvrec.c_since;
  if (lvrec.r_since!=-1 && lvrec.r_since>dateRange[0]) dateRange[0]=lvrec.r_since;
  if (lvrec.c_until!=-1) dateRange[1]=lvrec.c_until;
  if (lvrec.r_until!=-1 && lvrec.r_until<dateRange[1]) dateRange[1]=lvrec.r_until;
  if (vers==-1 || runStart<lookupDate[0] || runStart>lookupDate[1] ||
      dateRange[0]!=lookupDate[0] || dateRange[1]!=lookupDate[1]) {
    lookupDate[0]=dateRange[0];
    lookupDate[1]=dateRange[1];
    return getActRunId();
  } else return vers;
notfound:
  return -1;
};

Bool_t HStartParOraIo::read(HStartLookup* pPar, Int_t* set) {
  // reads and fills the container "StartLookup" for mapping TDC channels
  // to strips
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getLookupVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->clear();
  pPar->setInputVersion(version,inputNumber);

  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int cr[START_MAXSTRIPS];
      int sl[START_MAXSTRIPS];
      int ch[START_MAXSTRIPS];
      int mo[START_MAXSTRIPS];
      int st[START_MAXSTRIPS];
    } lookup;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HStartLookup*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT crate, slot, channel, module, strip
           INTO :lookup
           FROM tof_ana.start_lookup_at_date;
  for(Int_t i=0;i<sqlca.sqlerrd[2];i++) {
    Int_t m=lookup.mo[i];
    if (set[m]) {
      pPar->setAddress(lookup.cr[i]-1,lookup.sl[i]-1,lookup.ch[i],
                       m,lookup.st[i]);
      initModules->AddAt(m+1,m);
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<maxModules;i++) {
    if (set[i]>0 && initModules->At(i)<=0) allFound=kFALSE;
  }
  if (allFound) pPar->setChanged();
  return allFound;
};
 

Bool_t HStartParOraIo::read(HStartGeomPar* pPar, Int_t* set) {
  // reads the geometry of the START and fills the StartGeomPar container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (contVers!=-1 && contVers==version) return kTRUE;
  Bool_t allFound=readModGeomNames(pPar,set);
  if (!pPar->hasChanged()) return kTRUE;
  if (allFound) {
    readCompGeomNames(pPar,set);
    allFound=readGeometry(pPar,set);     // in base class
  }
  for(Int_t i=0;i<maxModules;i++) {
    if (initModules->At(i)) set[i]=0;
  }
  printInfo("StartGeomPar: module(s) initialized from Oracle: ");
  return allFound;
}


Bool_t HStartParOraIo::readModGeomNames(HStartGeomPar* pPar,Int_t* set) {
  // reads the geometry object names of all modules and the geometry version
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int pos[START_MAXMODS];
      varchar oname[START_MAXMODS][9];
      int vers[START_MAXMODS];
    } mods;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readModGeomNames");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_pos, geom_obj_name, geom_vers_index
           INTO :mods
           FROM start_ana.det_setup_at_date;
  Int_t nMods=sqlca.sqlerrd[2]; // number of rows returned by select
  Int_t contVers=pPar->getInputVersion(inputNumber);
  for(Int_t i=0;i<nMods;i++) {
    if (mods.vers[i]!=contVers) {
      pPar->setInputVersion(mods.vers[i],inputNumber);
      pPar->setChanged();
    }
  } 
  if (!pPar->hasChanged()) return kTRUE;
  initModules->Reset();
  Int_t m;
  for(Int_t i=0;i<nMods;i++) {
    m=mods.pos[i];
    HModGeomPar* pMod=pPar->getModule(-1,m);
    if (set[m] && pMod) {
      mods.oname[i].arr[mods.oname[i].len]='\0';
      pMod->SetName((char*)(mods.oname[i].arr));
      initModules->AddAt(m+1,m);
      pMod->setRefName(pMod->GetName());
      Int_t mr=pPar->getModNumInMod(pMod->GetName());
      HGeomCompositeVolume* refMod=pPar->getRefVolume(mr);
      if (refMod==0) {
        refMod=new HGeomCompositeVolume(pPar->getNumComponents());
        refMod->SetName(pMod->GetName());
        pPar->addRefVolume(refMod,mr);
      }
      pMod->setVolume(refMod);
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<maxModules;i++) {
    if (set[i]>0 && initModules->At(i)==0) allFound=kFALSE;
  }
  pPar->setChanged();
  return allFound;
};


Bool_t HStartParOraIo::readCompGeomNames(HStartGeomPar* pPar,Int_t* set) {
  // reads the geometry object names of all modules and the geometry version
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int pos[START_MAXSTRIPS];
      int strip[START_MAXSTRIPS];
      varchar oname[START_MAXSTRIPS][9];
    } strips;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readCompGeomNames");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_pos, strip_no, geom_obj_name
           INTO :strips
           FROM start_ana.det_strip;
  Int_t nStrips=sqlca.sqlerrd[2]; // number of rows returned by select
  Int_t m;
  for(Int_t i=0;i<nStrips;i++) {
    m=strips.pos[i];
    HModGeomPar* pMod=pPar->getModule(-1,m);
    if (set[m] && pMod) {
      HGeomCompositeVolume* pRefMod=pMod->getRefVolume();
      HGeomVolume* volu=pRefMod->getComponent(strips.strip[i]);
      strips.oname[i].arr[strips.oname[i].len]='\0';
      volu->SetName((char*)(strips.oname[i].arr));
      initModules->AddAt(m+1,m);
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<maxModules;i++) {
    if (set[i]>0 && initModules->At(i)==0) allFound=kFALSE;
  }
  return allFound;
};


Int_t HStartParOraIo::writePar(HStartCalPar* pPar) {
  // creates a new version and writes the calibration parameters to Oracle
  cout<<"****************************************************************\n";
  Int_t version=createCalparVers();
  if (version==-1) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int pos[START_MAXSTRIPS];
    int strip[START_MAXSTRIPS];
    int vers[START_MAXSTRIPS];
    float slo[START_MAXSTRIPS];
    float ofs[START_MAXSTRIPS];
    int rows_to_insert;
  EXEC SQL END DECLARE SECTION;
  for(Int_t m=0; m<pPar->getSize(); m++) {
    HStartCalParMod& rMod= (*pPar)[m];
    Int_t nChan=0;
    if (startIds->At(m)>0) {  
      for(Int_t c=0; c<rMod.getSize(); c++) {
        HStartCalParChan& chan= rMod[c];
//        id[nChan]=m*100+c;
        pos[nChan]=m;
        strip[nChan]=c;
        vers[nChan]=version;
        slo[nChan]=chan.getSlope();
        ofs[nChan]=chan.getOffset();
        nChan++;
      }
    }
    if (nChan==0) continue;
    rows_to_insert=nChan;
//    Int_t nStrips=countStrips(m);
//    if (nChan != nStrips) {
    if (nChan != startIds->At(m)) {
      Error("writePar(HStartCalPar*)",
            "\n Number of strips in Oracle:       %i"
            " \n Number of channels in StartCalPar: %i\n",
              startIds->At(m),nChan);
      rollback();
      return -1;
    }
    EXEC SQL WHENEVER SQLERROR GOTO not_found;
    EXEC SQL WHENEVER NOT FOUND GOTO not_found;
    EXEC SQL FOR :rows_to_insert
      INSERT INTO start_ana.cal_par (det_strip_id, cal_par_vers_id,
                                         slope, offset)
            VALUES (start_ana.calpar_query.get_strip_id(:pos,:strip), :vers, :slo, :ofs);
      cout<<"module_pos: "<<m<<"    "<<rows_to_insert<<" rows inserted\n";
  }
  commit();
  pPar->setChanged(kFALSE);
  return version;
not_found:
  showSqlError("writePar(HStartCalPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;
}


void HStartParOraIo::printInfo(Text_t* msg) {
  // prints the modules initialized from Oracle
  // will later go to the log file
  Bool_t first=kTRUE;
  for(Int_t i=0;i<maxModules;i++) {
    if (initModules->At(i)) {
      if (first) {
        cout<<msg;
        first=kFALSE;
      }
      cout<<(initModules->At(i)-1)<<" ";
    }
  }
  cout<<'\n';
}


Int_t HStartParOraIo::createCalparVers() {
  // creates a new version for the calibration parameters
  // return the new version
  if (author.IsNull()) {
    Error("createCalparVers(...)",
          "author of calibration parameters not defined");
    return -1;
  }
  if (description.IsNull()) {
    Error("createCalparVers(...)",
          "descriction of calibration parameters not defined");
    return -1;
  }
 if (runsUsed.IsNull()) {
    Error("createCalparVers(...)",
          "runs used for calibration parameters not defined");
    return -1;
  }
  EXEC SQL BEGIN DECLARE SECTION;
    char* creator;
    char* descript;
    char* runs;
    int vers=-1;
  EXEC SQL END DECLARE SECTION;
  creator=(char*)author.Data();
  descript=(char*)description.Data();
  runs=(char*)runsUsed.Data();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL EXECUTE
    BEGIN
      INSERT INTO start_ana.cal_par_vers (author, description, runs_used)
        VALUES (:creator, :descript, :runs);
      SELECT start_ana.calpar_query.get_curr_version INTO :vers FROM DUAL;
    END;
  END-EXEC;
  cout<<"******    Version cal_par_vers_id "<<vers<<" created\n";
  return vers;
not_found:
  showSqlError("createCalparVers()");
  return vers;
}


Int_t HStartParOraIo::countStrips(Int_t mod_pos) {
  // returns the number of strips of the module at position mod_pos
  EXEC SQL BEGIN DECLARE SECTION;
    int mo;
    int num;
  EXEC SQL END DECLARE SECTION;
  mo=mod_pos;
  EXEC SQL WHENEVER SQLERROR DO
    showSqlError("countStrips(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;
  EXEC SQL SELECT COUNT(det_strip_id) INTO :num
           FROM start_ana.det_strip
           WHERE module_pos=:mo;
  return num;
notfound:
  return 0;
}


void HStartParOraIo::resetComments(void) {
  // resets the comments used to create a new version
  author="";
  description="";
  runsUsed="";
}


void HStartParOraIo::clearVersDate(Double_t* p) {
  // clears a date range array
  p[0]=-1;
  p[1]=1.e+99;
}
 

