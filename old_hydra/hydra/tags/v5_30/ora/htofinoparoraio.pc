//*-- AUTHOR : Ilse Koenig
//*-- Modified : 12/02/2001 by I. Koenig
//*-- Created : 08/01/2001

//////////////////////////////////////////////////////////////////////////////
// HTofinoParOraIo
//
// Interface class to database Oracle for input/output of parameters needed
// by the Tofino
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////

#include "htofinoparoraio.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hspectrometer.h"
#include "hdetector.h"
#include "htofinodetector.h"
#include "htofinolookup.h"
#include "htofinogeompar.h"
#include "hgeomcompositevolume.h"
#include <iostream.h>
#include <unistd.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// SQL Communications Area
#include <sqlca.h>

ClassImp(HTofinoParOraIo)

#define TOFINO_MAXMODS 6
#define TOFINO_MAXCELL 4
#define TOFINO_MAXCHAN 48

HTofinoParOraIo::HTofinoParOraIo(HOraConn* pC) : HDetParOraIo(pC) {
  // constructor
  // sets the name of the I/O class "HTofinoParIo"
  // gets the pointer to the connection class
  fName="HTofinoParIo";
  pVersId=-1;
  initModules=new TArrayI(TOFINO_MAXMODS);
  tofinoIds=0;
  lookupDate=0;
}

HTofinoParOraIo::~HTofinoParOraIo() {
  // destructor
  if (initModules) delete initModules;
  if (tofinoIds) delete tofinoIds;
  if (lookupDate) delete [] lookupDate;
}
  
Bool_t HTofinoParOraIo::init(HParSet* pPar,Int_t* set) {
  // calls special read-function for each parameter container
  if (startIo()==-1) return kFALSE; // no modules found
  const Text_t* name=pPar->GetName();
  if (strcmp(name,"TofinoLookup")==0) return read(((HTofinoLookup*)pPar),set); 
  if (strcmp(name,"TofinoGeomPar")==0) return read(((HTofinoGeomPar*)pPar),set);
  cout<<"initialization of "<<name<<" not possible from Oracle!"<<endl;
  return kFALSE;
}

Int_t HTofinoParOraIo::write(HParSet* pPar) {
  // calls the appropriate write function for the container
  return 0;
}

Int_t HTofinoParOraIo::startIo(void) {
  if ((runStart=getRunStart())==-1) return -1;
  if (tofinoIds==0) {
    tofinoIds=new TArrayI(TOFINO_MAXMODS);
    readIds();
  }
  return pVersId;  // is -1 if no modules found
}

Int_t HTofinoParOraIo::readIds() {
  // reads the id numbers of all modules defined for the actual run
  // and stores them in array tofinoIds
  // returns the run id if at least one module can be found
  // returns -1 if nothing is found
  for(Int_t i=0;i<TOFINO_MAXMODS;i++) tofinoIds->AddAt(0,i);
  pVersId=-1;
  HTofinoDetector* det=(HTofinoDetector*)(gHades->getSetup()->getDetector("Tofino"));
  EXEC SQL BEGIN DECLARE SECTION;
    int id[TOFINO_MAXMODS];
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readIds()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module
    INTO :id
    FROM tofino_ana.det_setup_at_run;
  Int_t nMods=sqlca.sqlerrd[2];
  for(Int_t i=0;i<nMods;i++) {
    Int_t s=id[i]-1;
    if (det->getModule(s,0)) tofinoIds->AddAt(id[i],s);
  }
  if (nMods>0) pVersId=getActRunId();
  return pVersId;
}

void HTofinoParOraIo::printIds() {
  // prints the id numbers of all modules
  if (tofinoIds) {
    for(Int_t i=0;i<TOFINO_MAXMODS;i++)
      cout<<"sector: "<<i+1<<"   tofino id: "<<tofinoIds->At(i)<<"\n";
  }
}

Int_t HTofinoParOraIo::getLookupVersion(Int_t version) { 
  // reads the newest version number for the lookup table needed by the
  // unpacker valid for the current event file
  if (!lookupDate) {
    lookupDate=new Double_t[2];
    clearVersDate(lookupDate);
  }
  Double_t dateRange[2];
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      double c_since;
      double c_until;
      double r_since;
      double r_until;
    } lvrec;
    struct {
      short c_since_ind;
      short c_until_ind;
      short r_since_ind;
      short r_until_ind;
    } lvrec_ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getLookupVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;
  EXEC SQL SELECT hdate.to_ansitime(config_since), 
                  hdate.to_ansitime(config_until),
                  hdate.to_ansitime(dc_since),
                  hdate.to_ansitime(dc_until)
    INTO :lvrec INDICATOR :lvrec_ind
    FROM tof_ana.tofino_lookup_time_range;
  if (lvrec.c_since!=-1) dateRange[0]=lvrec.c_since;
  if (lvrec.r_since!=-1 && lvrec.r_since>dateRange[0]) dateRange[0]=lvrec.r_since;
  if (lvrec.c_until!=-1) dateRange[1]=lvrec.c_until;
  if (lvrec.r_until!=-1 && lvrec.r_until<dateRange[1]) dateRange[1]=lvrec.r_until;
  if (version==-1 || runStart<lookupDate[0] || runStart>lookupDate[1] ||
      dateRange[0]!=lookupDate[0] || dateRange[1]!=lookupDate[1]) {
    lookupDate[0]=dateRange[0];
    lookupDate[1]=dateRange[1];
    return getActRunId();
  } else return version;
notfound:
  return -1;
};

Bool_t HTofinoParOraIo::read(HTofinoLookup* pPar, Int_t* set) {
  // reads the lookup table (parameter container TofinoLookup) needed by the unpacker
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getLookupVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->clear();
  pPar->setInputVersion(version,inputNumber);
  initModules->Reset();
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int crate[TOFINO_MAXCHAN];
      int slot[TOFINO_MAXCHAN];
      int chan[TOFINO_MAXCHAN];
      char branch[TOFINO_MAXCHAN][2];
      int mod[TOFINO_MAXCHAN];
      int cell[TOFINO_MAXCHAN];
    } lrec;
    struct {
      short crate[TOFINO_MAXCHAN];
      short slot[TOFINO_MAXCHAN];
      short chan[TOFINO_MAXCHAN];
      short branch[TOFINO_MAXCHAN];
      short mod[TOFINO_MAXCHAN];
      short cell[TOFINO_MAXCHAN];
    } lrec_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HTofinoLookup*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT crate, slot, channel, branch, module, paddle
           INTO :lrec INDICATOR :lrec_Ind
           FROM tof_ana.tofino_lookup_at_date;
  for(Int_t i=0;i<sqlca.sqlerrd[2];i++) {
    Int_t s=lrec.mod[i]-1;
    if (set[s]) {
      pPar->setAddress(lrec.crate[i]-1,lrec.slot[i]-1,lrec.branch[i][0],
                   lrec.chan[i],s,0,lrec.cell[i]-1);
      initModules->AddAt(s+1,s);
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<TOFINO_MAXMODS;i++) {
    if (set[i]>0 && initModules->At(i)<=0) allFound=kFALSE;
  }
  if (allFound) pPar->setChanged();
  return allFound;
}

Bool_t HTofinoParOraIo::read(HTofinoGeomPar* pPar, Int_t* set) {
  // reads the geometry of the TOFINO and fills the TofinoGeomPar container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=readGeomVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);
  Bool_t allFound=kFALSE;
  if ((allFound=readModGeomNames(pPar,set))) {
    readCompGeomNames(pPar,set);
    allFound=readGeometry(pPar,set);     // in base class
  }
  for(Int_t i=0;i<TOFINO_MAXMODS;i++) {
    if (initModules->At(i)) set[i]=0;
  }
  printInfo("TofinoGeomPar: module(s) initialized from Oracle: ");
  return allFound;
}

Bool_t HTofinoParOraIo::readModGeomNames(HTofinoGeomPar* pPar,Int_t* set) {
  // reads the tofino_pos_id of all modules
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int id[TOFINO_MAXMODS];
      varchar oname[TOFINO_MAXMODS][9];
    } mods;
    struct {
      short id_Ind[TOFINO_MAXMODS];
      short oname_Ind[TOFINO_MAXMODS];
    } mods_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readModGeomNames()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module, geom_obj
    INTO :mods INDICATOR :mods_Ind
    FROM tofino_ana.det_setup_at_run;
  char ref[10];
  initModules->Reset();
  for(Int_t i=0;i<sqlca.sqlerrd[2];i++) {
    Int_t s=mods.id[i]-1;
    HModGeomPar* pMod=pPar->getModule(s,0);
    if (pMod && set[s]) {
      if (mods_Ind.oname_Ind[i]!=-1) {
        mods.oname[i].arr[mods.oname[i].len]='\0';
        pMod->SetName((char*)(mods.oname[i].arr));
        initModules->AddAt(s+1,s);
        strcpy(ref,(char*)(mods.oname[i].arr));
        ref[3]='1'; // reference module in sector 1
                    // not yet introduced in database
        pMod->setRefName(ref);
        Int_t mr=pPar->getModNumInMod(ref);
        HGeomCompositeVolume* refMod=pPar->getRefVolume(mr);
        if (refMod==0) {
          refMod=new HGeomCompositeVolume(pPar->getNumComponents());
          refMod->SetName(ref);
          pPar->addRefVolume(refMod,mr);
        }
        pMod->setVolume(refMod);
      }
    }
  }
  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<TOFINO_MAXMODS;i++) {
    if (set[i]>0 && initModules->At(i)==0) allFound=kFALSE;
  }
  return allFound;
}

Bool_t HTofinoParOraIo::readCompGeomNames(HTofinoGeomPar* pPar,Int_t* set) {
  // reads the names of all paddles in the geometry tables
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int cell[TOFINO_MAXCELL];
      varchar oname[TOFINO_MAXCELL][9];
    } comps;
    struct {
      short cell_Ind[TOFINO_MAXCELL];
      short oname_Ind[TOFINO_MAXCELL];
    } comps_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readCompGeomNames(...)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT paddle_nr, geom_obj_name
    INTO :comps INDICATOR :comps_Ind
    FROM tofino_ana.paddle
    WHERE det_module_id=1;         // reference module in sector 1
  HModGeomPar* pMod=0;
  for(Int_t s=0;s<TOFINO_MAXMODS;s++) {
    pMod=pPar->getModule(s,0);
    if (pMod) break;
  }
  if (pMod) {
    HGeomCompositeVolume* pRefMod=pMod->getRefVolume();
    for(Int_t k=0;k<sqlca.sqlerrd[2];k++) {
      if (comps_Ind.oname_Ind[k]!=-1) {
        comps.oname[k].arr[comps.oname[k].len]='\0';
        HGeomVolume* volu=pRefMod->getComponent((comps.cell[k]-1));
        volu->SetName((char*)(comps.oname[k].arr));
      }
    }
  }
  if (sqlca.sqlerrd[2]>0) return kTRUE;
  else return kFALSE;
}

void HTofinoParOraIo::printInfo(Text_t* msg) {
  // prints the modules initialized from Oracle
  // will later go to the log file
  Bool_t first=kTRUE;
  for(Int_t i=0;i<TOFINO_MAXMODS;i++) {
    if (initModules->At(i)) {
      if (first) {
        cout<<msg;
        first=kFALSE;
      }
      cout<<(initModules->At(i)-1)<<" ";
    }
  }
  cout<<'\n';
}

void HTofinoParOraIo::clearVersDate(Double_t* p) {
  // creates a date range array
  p[0]=-1;
  p[1]=1.E+11;
}
