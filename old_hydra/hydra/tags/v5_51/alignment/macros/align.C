/////////////////////////////////////////////////////////////////////////
//
// This macro make an alignment of all META detectors
// As an input a file generated by "makeInputNTuple.C" macro is taken.
// The flag IDEAL defines the setup of the procedure. If it is set then:
// 		two iterations are done:
//			1. Release only dZ shifts
//			2. dX, dY, dZ shifts are released. Start parameters taken from
//			   the previous iteration
// if the IDEAL flag is not set:
//		three iterations are done:
//			1. Only rotations released
//			2. Only shifts are released
//			3. All parameters are released
//		in every iteration parameters from previous step are used
//
// The results from the fitting are written to text files, if only the
// directory in which the files will be exists. They are printed on 
// the terminal as well.
//
// An NTuple with the results of fitting is generated (out.root).
// After each iteration a macro "checkResults.C" uses it to print some
// information about the quality of the results. 
//
// Use with: .x align.C
//
// M.Jaskula Fri Nov 30 00:23:06 CET 2001
//
/////////////////////////////////////////////////////////////////////////

//#define IDEAL

// Tof
Float_t tofxmislab[6] = { 0, 0, 0, 0, 0, 0 };
Float_t tofymislab[6] = { 0, 0, 0, 0, 0, 0 };
Float_t tofzmislab[6] = { 0, 0, 0, 0, 0, 0 };
Float_t tofrot1[6]    = { 0, 0, 0, 0, 0, 0 };
Float_t tofrot2[6]    = { 0, 0, 0, 0, 0, 0 };
Float_t tofrot3[6]    = { 0, 0, 0, 0, 0, 0 };

//Shower & Tofino
Float_t shoxmislab[6] = { 0, 0, 0, 0, 0, 0 };
Float_t shoymislab[6] = { 0, 0, 0, 0, 0, 0 };
#ifdef IDEAL
Float_t shozmislab[6] = { 120.,120.,120.,120.,350.,120.};
#else
Float_t shozmislab[6] = { 0, 0, 0, 0, 0, 0 };
#endif
Float_t shorot1[6]    = { 0, 0, 0, 0, 0, 0 };
Float_t shorot2[6]    = { 0, 0, 0, 0, 0, 0 };
Float_t shorot3[6]    = { 0, 0, 0, 0, 0, 0 };

char          sNTupleFile[] = "aligment.root";
char          sParamFile[]  = "currentParams.root";
int           iRunId        = 990403820;
char          sOutFile[]    = "out.root";

#ifdef IDEAL
char          sHTML1[]      = "Results/tab1.html";
char          sHTML2[]      = "Results/tab2.html";
char          sLog[]        = "Results/autologs.txt";
char          sHTMLLog[]    = "Results/htmllogs.html";
#else
char          sHTML1[]      = "Results/tab3.html";
char          sHTML2[]      = "Results/tab4.html";
char          sLog[]        = "Results/autologs2.txt";
char          sHTMLLog[]    = "Results/htmllogs2.html";
#endif

// -----------------------------------------------------------------------------

void printString(char *pFileName, char *pString)
{
FILE *pFile = stdout;

    if((pFileName != NULL) && ((pFile = fopen(pFileName, "a")) == NULL))
    {
        fprintf(stderr, "Cannot open file %s for output\n", pFileName);
        return;
    }

    fprintf(pFile, "%s", pString);

    if(pFile != stdout)
        fclose(pFile);
}

// -----------------------------------------------------------------------------

void printPreTags(int iSystem, int iSector, int iStep, char *pFileName)
{
char ss[1000];
char zz[1000];

    strcpy(ss, (iSystem) ? "Tof" : "Shower");
    sprintf(zz, "</pre>\n<h3>%s %d</h3>\n<h4><a name=\"%s %d %d\">"
                "Step %d</a></h4>\n<pre>\n",
                ss, iSector, ss, iSector, iStep, iStep);

    printString(pFileName, zz);
}
// -----------------------------------------------------------------------------

void makeAlign(int iSystem, int iSector)
{
HMetaAligner *pAligner;
int           i;
int           iStep;

    pAligner = new HMetaAligner(sNTupleFile, iSector, iSystem,
                        sParamFile, iRunId);

    pAligner->setError(0.01);
    pAligner->setMigRad(500);
    pAligner->setTukayConst(6.0);
    pAligner->setNormalize();
    pAligner->setImprove();

    for(i = 0; i < 6; i++)
        pAligner->setStep(i, (i < 3) ? 100.0 : 0.0);

    // set start values
    pAligner->setValue(0, (iSystem == 0)
                    ? shoxmislab[iSector] : tofxmislab[iSector]);
    pAligner->setValue(1, (iSystem == 0)
                    ? shoymislab[iSector] : tofymislab[iSector]);
    pAligner->setValue(2, (iSystem == 0)
                    ? shozmislab[iSector] : tofzmislab[iSector]);
    pAligner->setValue(3, (iSystem == 0) ? shorot1[iSector] : tofrot1[iSector]);
    pAligner->setValue(4, (iSystem == 0) ? shorot2[iSector] : tofrot2[iSector]);
    pAligner->setValue(5, (iSystem == 0) ? shorot3[iSector] : tofrot3[iSector]);

    pAligner->fixAll();

#ifdef IDEAL
    iStep = 1;
    pAligner->releaseParam(2);
#else
    iStep = 5;
    for(i = 0; i < 3; i++)
        pAligner->releaseParam(i);
#endif

    pAligner->runFit(kTRUE, sOutFile, 0);

    // add results to the log file
    pAligner->print(sLog);
    printString(sLog, "\n");
    checkResultsFunction(sLog);
    printString(sLog, "\n");
    // add fits to the html log file
    printPreTags(iSystem, iSector, iStep, sHTMLLog);
    checkResultsFunction(sHTMLLog);
    // add results to the html table
    pAligner->printHtmlRow(sHTML1);

#ifdef IDEAL
//  goto lab_End;

    iStep = 2;
    pAligner->releaseParam(0);
    pAligner->releaseParam(1);
    pAligner->contFit(kTRUE, sOutFile, 0);
#else
    iStep = 7;
    pAligner->reversFixed();
    pAligner->contFit(kTRUE, sOutFile, 0);
    pAligner->print(sLog);
    printString(sLog, "\n");
    checkResultsFunction(sLog);
    printString(sLog, "\n");

    pAligner->releaseAll();
    pAligner->contFit(kTRUE, sOutFile, 0);
#endif

    // add results to the log file
    pAligner->print(sLog);
    printString(sLog, "\n");
    checkResultsFunction(sLog);
    printString(sLog, "\n");
    // add fits to the html log file
    printPreTags(iSystem, iSector, iStep, sHTMLLog);
    checkResultsFunction(sHTMLLog);
    // add results to the html table
    pAligner->printHtmlRow(sHTML2);

lab_End:

    delete pAligner;
    pAligner = NULL;
}

// -----------------------------------------------------------------------------

void align(void)
{
int           iSector;
int           iSystem;

    gROOT->LoadMacro("checkResults.C");

    for(iSystem = 0; iSystem <= 1; iSystem++)
    {
        for(iSector = 0; iSector < 6; iSector++)
        {
            makeAlign(iSystem, iSector);
        }
    }
}

