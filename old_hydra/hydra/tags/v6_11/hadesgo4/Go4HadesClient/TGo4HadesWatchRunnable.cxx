/* Generated by Together */

#include "TGo4HadesWatchRunnable.h"
#include "Go4HadesClient/TGo4HadesClient.h"
#include "Go4TaskHandler/TGo4ClientStatus.h"

const UInt_t TGo4HadesWatchRunnable::fguWATCHINTERVAL=5000;


TGo4HadesWatchRunnable::TGo4HadesWatchRunnable(Text_t* name, TGo4HadesClient* cli)
: TGo4Runnable(name,cli)
{
   TRACE((15,"TGo4HadesWatchRunnable::TGo4HadesWatchRunnable(Text_t*,TGo4ExampleClient*) constructor",__LINE__, __FILE__));
   fxAnalysis=cli->GetAnalysis();
 
}

TGo4HadesWatchRunnable::~TGo4HadesWatchRunnable()
{
  TRACE((15,"TGo4HadesWatchRunnable::~TGo4HadesWatchRunnable() destructor",__LINE__, __FILE__));

}

Int_t TGo4HadesWatchRunnable::Run(void*)
{
   TRACE((12,"TGo4HadesWatchRunnable::Run()",__LINE__, __FILE__));

   TGo4HadesClient* cli= dynamic_cast<TGo4HadesClient*>(fxManager);  
   
//   static Int_t counter=0;
//   Text_t namebuffer[256];
//   sprintf(namebuffer,"Status: %d from WatchRunnable", counter++);
//   TGo4ClientStatus* state=0;
   
   cli->SendAnalysisStatus();
   
/////////Old stuff for the demo
   //      {


//      TGo4LockGuard mainguard;
//         state=cli->CreateStatus();     
         // for compatibility reasons, later use constant status buffer without lock
//         cli->SendStatus(state);
//         if(state)
//            {
//               cout << "Watch Runnable: Put "<< state->GetName() <<" statusobject into status queue"<<endl;      
//               
//               fxStatusQ->AddBufferFromObject(state);
//         }
//         else
//            {
//               cout << "Watch Runnable: zero state object pointer"<<endl;
//            }
      //// for demo reasons: put certain object into data queue
//            cout << " Watch Runnable: Sending Object POLQ12" << endl;
//            cli->SendObject("POLQ12");
      /// end demo       
//      cout << " Watch Runnable: still alive" << endl;
//      } // TGo4LockGuard
      
   TGo4Thread::Sleep(fguWATCHINTERVAL);
   return 0;
}

ClassImp(TGo4HadesWatchRunnable)  
