//*-- AUTHOR : Ilse Koenig
//*-- Created : 06/07/2000 by I. Koenig

//////////////////////////////////////////////////////////////////////////////
// HShowerParOraIo
//
// Interface class to database Oracle for input/output of parameters needed
// by the SHOWER detector
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////

#include "hshowerparoraio.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hspectrometer.h"
#include "hdetector.h"
#include "hshowerdetector.h"
#include "hshowercalpar.h"
#include <iostream.h>
#include <unistd.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// SQL Communications Area
#include <sqlca.h>

ClassImp(HShowerParOraIo)

#define SHOWER_MAXMODS 18
#define SHOWER_MAXPADS 1064

HShowerParOraIo::HShowerParOraIo(HOraConn* pC) : HDetParOraIo(pC) {
  // constructor
  // sets the name of the I/O class "HShowerParIo"
  // gets the pointer to the connection class
  fName="HShowerParIo";
  pVersId=-1;
  initModules=new TArrayI(SHOWER_MAXMODS);
  showerIds=0;
  calparDate=0;
  calparVersions=0;
  resetComments();
}


HShowerParOraIo::~HShowerParOraIo() {
  // destructor
  if (initModules) delete initModules;
  if (showerIds) delete showerIds;
  if (calparDate) delete [] calparDate;
  if (calparVersions) delete calparVersions;
}


Bool_t HShowerParOraIo::init(HParSet* pPar,Int_t* set) {
  // calls special read-function for each parameter container
  if (startIo()==-1) return kFALSE; // no modules found
  const Text_t* name=pPar->GetName();
  if (strcmp(name,"ShowerCalPar")==0) return read(((HShowerCalPar*)pPar),set);
  cout<<"initialization of "<<name<<" not possible from Oracle!"<<endl;
  return kFALSE;
}

Int_t HShowerParOraIo::write(HParSet* pPar) {
  // calls the appropriate write function for the container
  if (startIo()==-1) return kFALSE; // no modules found
  const Text_t* name=pPar->GetName();
  if (!strcmp(name,"ShowerCalPar"))
     return writePar((HShowerCalPar*)pPar);
  return 0;
}


Int_t HShowerParOraIo::startIo(void) {
  if ((runStart=getRunStart())==-1) return -1;
  if (showerIds==0) {
    showerIds=new TArrayI(SHOWER_MAXMODS);
    readIds();
  }
  return pVersId;  // is -1 if no modules found
}


Int_t HShowerParOraIo::readIds() {
  // reads the id numbers of all modules defined for actual run
  // and stores them in array showerIds
  // returns the run id if at least one module can be found
  // returns -1 if nothing is found
  for(Int_t i=0;i<SHOWER_MAXMODS;i++) showerIds->AddAt(0,i);
  pVersId=-1;
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int id[SHOWER_MAXMODS];
      int sec[SHOWER_MAXMODS];
      int pla[SHOWER_MAXMODS];
    } mods;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readIds()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_id, sector, module
    INTO :mods
    FROM shower_anatest.shower_setup_at_run;
  Int_t nMods=sqlca.sqlerrd[2]; // number of rows returned by select
  HShowerDetector* det=(HShowerDetector*)(gHades->getSetup()->getDetector("Shower"));
  Int_t s, p, pos;
  for(Int_t i=0;i<nMods;i++) {
    s=mods.sec[i]-1;
    p=mods.pla[i];
    pos=s*3+p;
    if (det->getModule(s,p)) showerIds->AddAt(mods.id[i],pos);
  }
  if (nMods>0) pVersId=getActRunId();
  //printIds();
  return pVersId;
}


void HShowerParOraIo::printIds() {
  // prints the id numbers of all modules
  if (showerIds) {
    for(Int_t i=0;i<6;i++) {
      cout<<"sector: "<<i+1<<"   shower ids:";
      for(Int_t j=0;j<3;j++) { cout<<" "<<showerIds->At(i*3+j); }
      cout<<'\n';
    }
    cout<<'\n';
  }
}


Int_t HShowerParOraIo::getCalparVersion(Int_t version) {
  // reads the newest version number for the calibration parameters
  // valid for the current event file
  if (!calparVersions) {
    calparVersions=new TArrayI(showerIds->GetSize());
    for(Int_t i=0;i<calparVersions->GetSize();i++) calparVersions->AddAt(-1,i);
  }
  if (calparDate) {
     if (version!=-1 && runStart>=calparDate[0] && runStart<=calparDate[1])
      return version;
  }
  else calparDate=new Double_t[2];
  clearVersDate(calparDate);
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int id[SHOWER_MAXMODS];
      int vers[SHOWER_MAXMODS];
      double since[SHOWER_MAXMODS];
      double until[SHOWER_MAXMODS];
    } cal;
    struct {
      short id[SHOWER_MAXMODS];
      short vers[SHOWER_MAXMODS];
      short since[SHOWER_MAXMODS];
      short until[SHOWER_MAXMODS];
    } cal_Ind;
  EXEC SQL END DECLARE SECTION;
  Int_t nMods=0;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getCalparVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_id, version, hdate.to_ansitime(valid_since),
                                hdate.to_ansitime(valid_until)
           INTO :cal INDICATOR :cal_Ind
           FROM shower_anatest.cal_vers_at_run;
  nMods=sqlca.sqlerrd[2];
  for(Int_t i=0;i<nMods;i++) {
    for(Int_t j=0;j<showerIds->GetSize();j++) {
      Int_t m=showerIds->At(j);
      if (m>0 && m==cal.id[i]) {
        calparVersions->AddAt(cal.vers[i],j);
        calparDate[0]=(cal.since[i]>calparDate[0]) ? cal.since[i]
                                                        : calparDate[0];
        calparDate[1]=(cal.until[i]<calparDate[1]) ? cal.until[i]
                                                        : calparDate[1];
      }
    }
  }
  cout<<"version range: "<<calparDate[0]<<" - "<<calparDate[1]<<endl;
  if (calparDate[0]>0) return getActRunId();
  return -1;
};


Bool_t HShowerParOraIo::read(HShowerCalPar* pPar, Int_t* set) {
  // reads the calibration parameters and fill the ShowerCalPar container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getCalparVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int c_vers;
    struct {
      int p_col[SHOWER_MAXPADS];
      int p_row[SHOWER_MAXPADS];
      float slo[SHOWER_MAXPADS];
      float ofs[SHOWER_MAXPADS];
    } cal;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HShowerCalPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE cal_cur CURSOR FOR
    SELECT pad_col, pad_row, gain, offset
      FROM shower_anatest.cal_par_all
      WHERE module_id = :id
        AND version = :c_vers;
  Bool_t allFound=kTRUE;
  initModules->Reset();
  HLocation loc;
  loc.setNIndex(4);
  HShowerCalParCell* pCell=0;
  for(Int_t i=0;i<pPar->getNSectors();i++) {
    for(Int_t j=0;j<pPar->getNModules();j++) {
      Int_t pos=i*3+j;
      if (set[pos]) {
        loc[0] = i;
        loc[1] = j;
        id=showerIds->At(pos);
        c_vers=calparVersions->At(pos);
        Int_t nPads=0;
        if (id>0 && c_vers>0) {
          EXEC SQL OPEN cal_cur;
          EXEC SQL FETCH cal_cur INTO :cal;
          nPads=sqlca.sqlerrd[2];
          for(Int_t k=0;k<nPads;k++) {
            loc[2] = cal.p_row[k];
            loc[3] = cal.p_col[k];
            pCell = (HShowerCalParCell*)pPar->getSlot(loc);
            if (pCell) {
              pCell = new(pCell) HShowerCalParCell;
              pCell->setSlope(cal.slo[k]);
              pCell->setOffset(cal.ofs[k]);
            }
            else {
              Error("read(HShowerCalPar*,Int_t*)",
                    "slot not found:  %i %i %i %i",loc[0],loc[1],loc[2],loc[3]);
              EXEC SQL CLOSE cal_cur;
              return kFALSE;
            }
          }
        }
        if (nPads>0) {
          set[pos]=0;
          initModules->AddAt(pos+1,pos);
        }
        else allFound=kFALSE;
      }
    }
  }
  EXEC SQL CLOSE cal_cur;
  pPar->setChanged();
  printInfo("ShowerCalPar: module(s) initialized from Oracle: ");
  return allFound;
};


Int_t HShowerParOraIo::writePar(HShowerCalPar* pPar) {
  // creates a new version and writes the calibration parameters to Oracle
  cout<<"****************************************************************\n";
  Int_t version=createCalparVers();
  if (version==-1) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int id[SHOWER_MAXPADS];
    int vers[SHOWER_MAXPADS];
    float slo[SHOWER_MAXPADS];
    float ofs[SHOWER_MAXPADS];
    int rows_to_insert;
  EXEC SQL END DECLARE SECTION;

  HLocation loc;
  loc.set(4,0,0,0,0);
  HShowerCalParCell* pCell=0;
  Float_t cs=0, co=0;
  for(Int_t s=0;s<pPar->getNSectors();s++) {
    for(Int_t m=0;m<pPar->getNModules();m++) {
      Int_t nCell=-1;
      Int_t sId=showerIds->At(s*3+m);
      if (sId>0) {
        loc[0] = s;
        loc[1] = m;
        for(Int_t r=0;r<pPar->getNRows();r++) {
          loc[2]=r;
          for(Int_t c=0;c<pPar->getNColumns();c++) {
            loc[3]=c;
            pCell = (HShowerCalParCell*)pPar->getObject(loc);
            if (pCell) {
              cs=pCell->getSlope();
              co=pCell->getOffset();
              if (co!=0 || cs!=1) { // only non-default values
                nCell++;
                if (nCell==SHOWER_MAXPADS) {
                  Error("writePar(HShowerCalPar*)","\n Number of Pads > 1024\n");
                  rollback();
                  return -1;
                }
                id[nCell]=sId*10000 + r*100 + c;
                vers[nCell]=version;
                slo[nCell]=cs;
                ofs[nCell]=co;
              }
            }
          }
        }
      }
      if (nCell==-1) continue;
      rows_to_insert=nCell+1;
      EXEC SQL WHENEVER SQLERROR GOTO not_found;
      EXEC SQL WHENEVER NOT FOUND GOTO not_found;
      EXEC SQL FOR :rows_to_insert
        INSERT INTO shower_anatest.cal_par (pad_id, cal_par_vers_id,
                                            gain, offset)
          VALUES (:id, :vers, :slo, :ofs);
      cout<<"module_id: "<<sId<<"    "<<rows_to_insert<<" rows inserted\n";
    }
  }
  cout<<"******    Calibration parameters written to Oracle\n";
  cout<<"****************************************************************\n";
  commit();
  pPar->setChanged(kFALSE);
  return version;
not_found:
  showSqlError("writePar(HShowerCalPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;
}


void HShowerParOraIo::printInfo(Text_t* msg) {
  // prints the modules initialized from Oracle
  // will later go to the log file
  Bool_t first=kTRUE;
  for(Int_t i=0;i<SHOWER_MAXMODS;i++) {
    if (initModules->At(i)) {
      if (first) {
        cout<<msg;
        first=kFALSE;
      }
      cout<<(initModules->At(i)-1)<<" ";
    }
  }
  cout<<'\n';
}


Int_t HShowerParOraIo::createCalparVers() {
  // creates a new version for the calibration parameters
  // return the new version
  if (author.IsNull()) {
    Error("createCalparVers(...)",
          "author of calibration parameters not defined");
    return -1;
  }
  if (description.IsNull()) {
    Error("createCalparVers(...)",
          "descriction of calibration parameters not defined");
    return -1;
  }
 if (runsUsed.IsNull()) {
    Error("createCalparVers(...)",
          "runs used for calibration parameters not defined");
    return -1;
  }
  EXEC SQL BEGIN DECLARE SECTION;
    char* creator;
    char* descript;
    char* runs;
    int vers=-1;
  EXEC SQL END DECLARE SECTION;
  creator=(char*)author.Data();
  descript=(char*)description.Data();
  runs=(char*)runsUsed.Data();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL EXECUTE
    BEGIN
      INSERT INTO shower_anatest.cal_par_vers (author, description, runs_used)
        VALUES (:creator, :descript, :runs);
      SELECT shower_anatest.cal_par_query.get_curr_version INTO :vers FROM DUAL;
    END;
  END-EXEC;
  cout<<"******    Version cal_par_vers_id "<<vers<<" created\n";
  return vers;
not_found:
  showSqlError("createCalparVers()");
  return vers;
}


void HShowerParOraIo::resetComments(void) {
  // resets the comments used to create a new version
  author="";
  description="";
  runsUsed="";
}


void HShowerParOraIo::clearVersDate(Double_t* p) {
  // clears a date range array
  p[0]=-1;
  p[1]=1.e+99;
}
 

