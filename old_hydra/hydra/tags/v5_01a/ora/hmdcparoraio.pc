//*-- AUTHOR : Ilse Koenig
//*-- Modified : 21/02/2000 by I.Koenig

//////////////////////////////////////////////////////////////////////////////
// HMdcParOraIo
//
// Interface class to database Oracle for input/output of parameters needed
// by the Mdc
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////

#include "hmdcparoraio.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hspectrometer.h"
#include "hdetector.h"
#include "hmdcdetector.h"
#include "hmdcrawstruct.h"
#include "hmdcgeomstruct.h"
#include "hmdccalparraw.h"
#include "hmdclookupgeom.h"
#include "hmdcdigitpar.h"
#include "hmdclayergeompar.h"
#include "hmdcmboreadout.h"
#include "hmdcgeompar.h"
#include "hgeomcompositevolume.h"
#include <iostream.h>
#include <unistd.h>
 
#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// SQL Communications Area
#include <sqlca.h>

ClassImp(HMdcParOraIo)

#define MDC_MAXMODS 24
#define MDC_MAXMOTHS 16
#define MDC_MAXLAYS 6
#define MDC_MAXWIRES 1320
#define MDC_MAXCHAN 1536

HMdcParOraIo::HMdcParOraIo(HOraConn* pC) : HDetParOraIo(pC) {
  // constructor
  // sets the name of the I/O class "HMdcParIo"
  // gets the pointer to the connection class
  fName="HMdcParIo";
  pVersId=-1;
  initModules=new TArrayI(MDC_MAXMODS);
  mdcIds=0;
  modIds=0;
  lookupgeomDate=0;
  mboreadoutDate=0;
  digiparDate=0;
  cal1parDate=0;
  cal1parVersions=0;
  resetComments();
}


HMdcParOraIo::~HMdcParOraIo() {
  // destructor
  if (initModules) delete initModules;
  if (mdcIds) delete mdcIds;
  if (modIds) delete modIds;
  if (lookupgeomDate) delete [] lookupgeomDate;
  if (mboreadoutDate) delete [] mboreadoutDate;
  if (digiparDate) delete [] digiparDate;
  if (cal1parDate) delete [] cal1parDate;
  if (cal1parVersions) delete cal1parVersions;
}


Bool_t HMdcParOraIo::init(HParSet* pPar,Int_t* set) {
  // calls special read-function for each parameter container
  if ((runStart=getRunStart())==-1) return kFALSE;
  if (mdcIds==0) {
    mdcIds=new TArrayI(MDC_MAXMODS);
    if (readIds()==-1) return kFALSE;
  }
  if (pVersId==-1) return kFALSE;  // no modules found
  const Text_t* name=pPar->GetName();
  if (strcmp(name,"MdcRawStruct")==0) return read(((HMdcRawStruct*)pPar),set);
  if (strcmp(name,"MdcGeomStruct")==0) return read(((HMdcGeomStruct*)pPar),set);
  if (strcmp(name,"MdcLookupGeom")==0) return read(((HMdcLookupGeom*)pPar),set);
  if (strcmp(name,"MdcMboReadout")==0) return read(((HMdcMboReadout*)pPar),set);
  if (strcmp(name,"MdcLayerGeomPar")==0) return read(((HMdcLayerGeomPar*)pPar),set);
  if (strcmp(name,"MdcGeomPar")==0) return read(((HMdcGeomPar*)pPar),set);
//  if (strcmp(name,"MdcCalPar")==0) return read(((HMdcCalPar*)pPar),set);
  if (strcmp(name,"MdcDigitPar")==0) return read(((HMdcDigitPar*)pPar),set);
  if (strcmp(name,"MdcCalParRaw")==0) return read(((HMdcCalParRaw*)pPar),set);
   cout<<"initialization of "<<name<<" not possible from Oracle!"<<endl;
  return kFALSE;
}


Int_t HMdcParOraIo::write(HParSet* pPar) {
  // calls the appropriate write function for the container
  if ((runStart=getRunStart())==-1) return -1;
  if (mdcIds==0) {
    mdcIds=new TArrayI(MDC_MAXMODS);
    if (readIds()==-1) return -1;
  }
  if (pVersId==-1) return -1;  // no modules found
  const Text_t* name=pPar->GetName();
  if (!strcmp(name,"MdcCalParRaw"))
     return writePar((HMdcCalParRaw*)pPar);
  return 0;
}


Int_t HMdcParOraIo::readIds() {
  // reads the id numbers of all modules defined for actual run
  // and stores them in array id
  // returns the run id if at least one module can be found
  // returns -1 if nothing is found
  for(Int_t i=0;i<MDC_MAXMODS;i++) mdcIds->AddAt(0,i); 
  pVersId=-1;

  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int mdc[MDC_MAXMODS]; 
      int sec[MDC_MAXMODS];
      int pla[MDC_MAXMODS];
    } mods;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("readIds()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL SELECT mdc_hwobj_id, sector, plane
    INTO :mods
    FROM mdc_ana.mdc_loc_at_run;

  Int_t nMods=sqlca.sqlerrd[2];
  Int_t maxId=0;
  HMdcDetector* det=(HMdcDetector*)(gHades->getSetup()->getDetector("Mdc"));
  Int_t s, p, pos;
  for(Int_t i=0;i<nMods;i++) {
    s=mods.sec[i]-1;
    p=mods.pla[i]-1;
    pos=s*4+p;
    if (det->getModule(s,p)) {
      mdcIds->AddAt(mods.mdc[i],pos);
      maxId=(mods.mdc[i]>maxId)?mods.mdc[i]:maxId;
    }
  }
  if (maxId>0) {
    pVersId=getActRunId();
    modIds=new TArrayI((++maxId));
    for(Int_t i=0;i<mdcIds->GetSize();i++) {
      Int_t j=mdcIds->At(i);
      if (j) modIds->AddAt(j,j);
    }
  }
  return pVersId;
}
 

void HMdcParOraIo::printIds() {
  // prints the id numbers of all modules
  if (mdcIds) {
    for(Int_t i=0;i<6;i++) {
      cout<<"sector: "<<i+1<<"   mdc ids:";
      for(Int_t j=0;j<4;j++) { cout<<" "<<mdcIds->At(i*4+j); }
      cout<<'\n';
    }
    cout<<'\n';
  }
}


Bool_t HMdcParOraIo::read(HMdcRawStruct* pPar,Int_t* set) {
  // reads the names (characterizes the position) of the motherboards
  // and the maximum number of TDCs on each of it and fills the
  // MdcRawStruct container
  Int_t nMoths=-1, pos, version=-1;
  char mboName[4];
  
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int mbo[MDC_MAXMOTHS]; 
      int nChan[MDC_MAXMOTHS];
    } moths;
    struct {
      short mbo_Ind[MDC_MAXMOTHS]; 
      short nChan_Ind[MDC_MAXMOTHS];
    } moths_Ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcRawStruct*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL DECLARE c1 CURSOR FOR
    SELECT  mbo_local_pos_id, n_tdc_chan
    FROM mdc_ana.mdcrawstruct_at_date
    WHERE mdc_hwobj_id=:id
    ORDER BY mbo_local_pos_id;

  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcRawStruct& mdc=*pPar;
  for(Int_t i=0;i<6;i++) {
    HMdcRawSecStru& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcRawModStru& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c1;
          EXEC SQL FETCH c1 INTO :moths INDICATOR :moths_Ind;
          nMoths=sqlca.sqlerrd[2];
          for(Int_t i=0;i<nMoths;i++) {
            sprintf(mboName,"%3i",moths.mbo[i]);
            mod[i].SetName(mboName);
            mod[i].setNTdcs(moths.nChan[i]);
            if (i==0) {
              set[pos]=0;
              initModules->AddAt(pos+1,pos);
            }
          }
          EXEC SQL CLOSE c1;
          if (version==-1 && nMoths>0) version=getActRunId();
        }
        else allFound=kFALSE;
      }
    }
  }
  pPar->setInputVersion(version,inputNumber);
  if (version==-1) return kFALSE;
  pPar->setChanged();
  printInfo("MdcRawStruct: module(s) initialized from Oracle: ");
  return allFound;
}   


Bool_t HMdcParOraIo::read(HMdcGeomStruct* pPar,Int_t* set) {
  // reads the number of cells in each layer and fills the
  // MdcGeomStruct container
  Int_t nLayers=-1, pos, version=-1;
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int lay[MDC_MAXLAYS];
      int nWir[MDC_MAXLAYS];
    } layers;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcGeomStruct*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL DECLARE c2 CURSOR FOR
    SELECT layer_nr, n_wires 
    FROM mdc_ana.mdclayerparam
    WHERE mdc_hwobj_id=:id;

  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcGeomStruct& mdc=*pPar;
  for(Int_t i=0;i<6;i++) {
    HMdcGeomSecStru& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcGeomModStru& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c2;
          EXEC SQL FETCH c2 INTO :layers;
          nLayers=sqlca.sqlerrd[2];
          if (nLayers!=MDC_MAXLAYS) allFound=kFALSE;
          for(Int_t i=0;i<nLayers;i++) {
            mod.fill((layers.lay[i]-1),layers.nWir[i]);
            if (i>0) {
              set[pos]=0;
              initModules->AddAt(pos+1,pos);
            }
          }
          EXEC SQL CLOSE c2;
          if (version==-1 && nLayers>0) version=getActRunId();
        }
        else allFound=kFALSE;
      }
    }
  }
  pPar->setInputVersion(version,inputNumber);
  pPar->setChanged();
  printInfo("MdcGeomStruct: module(s) initialized from Oracle: ");
  return allFound;
} 


Int_t HMdcParOraIo::getLookupVersion(Int_t vers) {
  // reads the version for the MdcLookupGeom container valid at the start time
  // of the actual run
  // if the version differs from the container version changes the container must be
  // reinitialized
  if (!lookupgeomDate) lookupgeomDate=new Double_t[2];
  else {
    if (vers!=-1 && runStart>=lookupgeomDate[0] && runStart<=lookupgeomDate[1])
      return vers;
  }
  clearVersDate(lookupgeomDate);

  EXEC SQL BEGIN DECLARE SECTION;
    double since;
    double until;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("getLookupVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;

  EXEC SQL SELECT hdate.to_ansitime(MAX(valid_since)),
                  hdate.to_ansitime(MIN(valid_until))
           INTO :since, :until
           FROM mdc_ana.fpc_loc
           WHERE hades_oper.run_query.get_date() BETWEEN valid_since AND valid_until
             AND invalid_since>SYSDATE;
  lookupgeomDate[0]=since;  
  lookupgeomDate[1]=until;  
  return getActRunId();
notfound:
  return -1;
}; 


Bool_t HMdcParOraIo::read(HMdcLookupGeom* pPar, Int_t* set) {
  // reads and fills the container "MdcLookupGeom" for mapping
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getLookupVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);

  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int mbo[MDC_MAXWIRES];
      int tdc[MDC_MAXWIRES];
      int chan[MDC_MAXWIRES];
      int lay[MDC_MAXWIRES];
      int wire[MDC_MAXWIRES];
    } lookup;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcLookupGeom*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE c3 CURSOR FOR
    SELECT  mbo_local_pos_id, tdc_nr, tdc_chan, layer_nr, wire_nr
    FROM mdc_ana.mdclookupgeom_at_date
    WHERE mdc_hwobj_id=:id
    ORDER BY mbo_local_pos_id;
     
  HMdcRawStruct* pRawStruct=
       (HMdcRawStruct*)gHades->getRuntimeDb()->getContainer("MdcRawStruct");
  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcLookupGeom& mdc=*pPar;
  Int_t nWires=-1, pos, mboNr=-1, mo, ml=-1, ch;
  char buf[4];
  for(Int_t i=0;i<6;i++) {
    HMdcLookupGSec& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcLookupGMod& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        HMdcRawModStru& pModStruct=(*pRawStruct)[i][j];
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c3;
          EXEC SQL FETCH c3 INTO :lookup;
          ml=-1;
          nWires=sqlca.sqlerrd[2];
          for(Int_t k=0;k<nWires;k++) {
            mo=lookup.mbo[k];
            if (mo>ml) {
              sprintf(buf,"%3i",mo);
              mboNr=pModStruct.getMboIndex(buf);
              ml=mo;
            }
            ch=(lookup.tdc[k]-1)*8 + lookup.chan[k] - 1;
            mod[mboNr][ch].fill((lookup.lay[k]-1),(lookup.wire[k]-1));
          }
          if (nWires>0) {
            set[pos]=0;
            initModules->AddAt(pos+1,pos);
          }
          else allFound=kFALSE;
         }
        else allFound=kFALSE;
      }
    }
  }
  EXEC SQL CLOSE c3;
  pPar->setChanged();
  printInfo("MdcLookupGeom: module(s) initialized from Oracle: ");
  return allFound;     
}; 
 

Int_t HMdcParOraIo::getReadoutVersion(Int_t vers) {
  // reads the version for the MboReadout container valid at the start time
  // of the actual run
  // if the version differs from the container version changes the container
  // must be reinitialized
  if (!mboreadoutDate) mboreadoutDate=new Double_t[2];
  else {
    if (vers!=-1 && runStart>=mboreadoutDate[0] && runStart<=mboreadoutDate[1])
      return vers;
  }
  clearVersDate(mboreadoutDate);

  EXEC SQL BEGIN DECLARE SECTION;
    double since1;
    double until1;
    double since2;
    double until2;
    double since3;
    double until3;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("getReadoutVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;

  EXEC SQL SELECT ma1, mi1, ma2, mi2, ma3, mi3
       INTO :since1 , :until1, :since2, :until2,:since3, :until3   
       FROM
         (SELECT hdate.to_ansitime(MAX(valid_since)) AS ma1,
                 hdate.to_ansitime(MIN(valid_until)) AS mi1
           FROM mdc_ana.mbo_lvl1_loc           
           WHERE hades_oper.run_query.get_date() BETWEEN valid_since AND valid_until
                 AND invalid_since>SYSDATE),
         (SELECT hdate.to_ansitime(MAX(valid_since)) AS ma2,
                 hdate.to_ansitime(MIN(valid_until)) AS mi2
            FROM mdc_ana.lvl1_loc
            WHERE hades_oper.run_query.get_date() BETWEEN valid_since AND valid_until
                 AND invalid_since>SYSDATE),
         (SELECT hdate.to_ansitime(MAX(valid_since)) AS ma3,
                 hdate.to_ansitime(MIN(valid_until)) AS mi3
            FROM mdc_ana.gtb_loc
            WHERE hades_oper.run_query.get_date() BETWEEN valid_since AND valid_until
                 AND invalid_since>SYSDATE);

  if (since1>since2) mboreadoutDate[0]=since1;
  else mboreadoutDate[0]=since2;
  if (since3>mboreadoutDate[0]) mboreadoutDate[0]=since3;
  if (until1<until2) mboreadoutDate[1]=until1;
  else mboreadoutDate[1]=until2;
  if (until3<mboreadoutDate[1]) mboreadoutDate[1]=until3;
  return getActRunId();
notfound:
  return -1;
} 


Bool_t HMdcParOraIo::read(HMdcMboReadout* pPar, Int_t* set) {
  // reads the lookup tables to connect the hardware adresses (sector, module,
  // motherboard, tdc channel) with the event readout adresses uses in the
  //  unpacker
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getReadoutVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);

  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int mbo [MDC_MAXMOTHS];
      int bus [MDC_MAXMOTHS];
      int busPos [MDC_MAXMOTHS];
      int roc [MDC_MAXMOTHS];
      int samPos [MDC_MAXMOTHS];
      int sam [MDC_MAXMOTHS];
    } readout;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcLookupGeom*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE c4 CURSOR FOR
    SELECT mbo_local_pos_id,mbo_pos_in_lvl1,roc_input_con, roc_pos_in_crate,
           sam_input_con,sam_pos
    FROM mdc_ana.mdcreadout_at_run
    WHERE mdc_hwobj_id = :id
    ORDER BY mbo_local_pos_id;

  HMdcRawStruct* pRawStruct=
       (HMdcRawStruct*)gHades->getRuntimeDb()->getContainer("MdcRawStruct");
  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcMboReadout& mdc=*pPar;
  Int_t pos, nMbo, mboNr=-1, mo;
  char buf[4];
  for(Int_t i=0;i<6;i++) {
    HMdcMboReadoutSec& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcMboReadoutMod& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        HMdcRawModStru& pModStruct=(*pRawStruct)[i][j];
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c4;
          EXEC SQL FETCH c4 INTO :readout;
          nMbo=sqlca.sqlerrd[2];
          for(Int_t k=0;k<nMbo;k++) {
            mo=readout.mbo[k];
            sprintf(buf,"%3i",mo);
            mboNr=pModStruct.getMboIndex(buf);
            HMdcMboReadoutMoth& moth=mod[mboNr];
            moth.setBus(readout.bus[k]);
            moth.setBusPos(readout.busPos[k]);
            moth.setRoc(readout.roc[k]);
            moth.setSamPos(readout.samPos[k]);
            moth.setSam(readout.sam[k]-1);
          }
          if (nMbo>0) {
            set[pos]=0;
            initModules->AddAt(pos+1,pos);
          }
          else allFound=kFALSE;
        }
        else allFound=kFALSE;
      }
    }
  }
  EXEC SQL CLOSE c4;
  pPar->setChanged();
  printInfo("MdcMboReadout: module(s) initialized from Oracle: ");
  return allFound;    
} 


Int_t HMdcParOraIo::getDigiparVersion(Int_t vers) {
  // reads the version for the digitization parameters valid at the start time
  // of the actual run
  // if the version differs from the container version changes the container must be
  // reinitialized
  if (!digiparDate) digiparDate=new Double_t[2];
  else {
    if (vers!=-1 && runStart>=digiparDate[0] && runStart<=digiparDate[1])
      return vers;
  }
  clearVersDate(digiparDate);

  EXEC SQL BEGIN DECLARE SECTION;
    double since;
    double until;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("getDigiparVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;

  EXEC SQL SELECT hdate.to_ansitime(MAX(valid_since)),
                  hdate.to_ansitime(MIN(valid_until))
           INTO :since, :until
           FROM mdc_ana.digi_par_mod_vers_at_run;
  digiparDate[0]=since;  
  digiparDate[1]=until;  
  return getActRunId();
notfound:
  return -1;
}; 

Bool_t HMdcParOraIo::read(HMdcDigitPar* pPar,Int_t* set) {
  // reads physical parameters for digitisation procedure
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getDigiparVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);

  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int lay[MDC_MAXLAYS];
      float vel[MDC_MAXLAYS];
      float eff[MDC_MAXLAYS];
      float p1[MDC_MAXLAYS];
      float p2[MDC_MAXLAYS];
      float p3[MDC_MAXLAYS];
      float p4[MDC_MAXLAYS];
      float p5[MDC_MAXLAYS];
  } digi;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcDigiPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE c5 CURSOR FOR
    SELECT layer_nr, driftvel, mdceff, fp1, fp2, fp3, fp4, fp5
    FROM mdc_ana.digi_par_at_run
    WHERE mdc_hwobj_id=:id;

  Int_t nLay=-1, pos;
  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcDigitPar& mdc=*pPar;
  for(Int_t i=0;i<mdc.getSize();i++) {
    HMdcDigitParSec& sec=mdc[i];
    for(Int_t j=0;j<sec.getSize();j++) {
      HMdcDigitParMod& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c5;
          EXEC SQL FETCH c5 INTO :digi;
          nLay=sqlca.sqlerrd[2];
          if (nLay==MDC_MAXLAYS) {
            set[pos]=0;
            initModules->AddAt(pos+1,pos);
          }
          else allFound=kFALSE;
          for(Int_t k=0;k<nLay;k++) {
            mod[(digi.lay[k]-1)].fill(digi.vel[k],digi.eff[k],digi.p1[k],digi.p2[k],
                        digi.p3[k],digi.p4[k],digi.p5[k]);
          }
          EXEC SQL CLOSE c5;
          if (version==-1 && nLay>0) version=getActRunId();
        }
        else allFound=kFALSE;
      }
    }
  }
  pPar->setInputVersion(version,inputNumber);
  pPar->setChanged();
  printInfo("MdcDigiPar: module(s) initialized from Oracle: ");
  return allFound; 
}; 

Bool_t HMdcParOraIo::read(HMdcLayerGeomPar* pPar,Int_t* set) {
  // reads geometry parameters of the layers
  Int_t nLayers=-1, pos, version=-1;
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int lay[MDC_MAXLAYS];
      float pitch[MDC_MAXLAYS];
      float dist[MDC_MAXLAYS];
      float angle[MDC_MAXLAYS];
      float cwire[MDC_MAXLAYS];
    } layers;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcLayerGeomPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL DECLARE c6 CURSOR FOR
    SELECT layer_nr, cell_pitch, cell_thickness, inclination_angle, central_wire_nr
    FROM mdc_ana.mdclayerparam
    WHERE mdc_hwobj_id=:id;

  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcLayerGeomPar& mdc=*pPar;
  for(Int_t i=0;i<6;i++) {
    HMdcLayerGeomParSec& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcLayerGeomParMod& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c6;
          EXEC SQL FETCH c6 INTO :layers;
          nLayers=sqlca.sqlerrd[2];
          if (nLayers==MDC_MAXLAYS) {
            set[pos]=0;
            initModules->AddAt(pos+1,pos);
          }
          else allFound=kFALSE;
          for(Int_t i=0;i<nLayers;i++) {
            mod[(layers.lay[i]-1)].fill(layers.pitch[i],layers.dist[i],
                                        layers.angle[i],layers.cwire[i]);
          }
          EXEC SQL CLOSE c6;
          if (version==-1 && nLayers>0) version=getActRunId();
        }
        else allFound=kFALSE;
      }
    }
  }
  pPar->setInputVersion(version,inputNumber);
  pPar->setChanged();
  printInfo("MdcLayerGeomPar: module(s) initialized from Oracle: ");
  return allFound;
} 
 

Bool_t HMdcParOraIo::read(HMdcGeomPar* pPar, Int_t* set) {
  // reads the geometry of the MDC and fills the MdcGeomPar container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=readGeomVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);
  Bool_t allFound=kFALSE;
  if ((allFound=readModGeomNames(pPar,set))) {
    readLayerGeomNames(pPar,set);
    allFound=readGeometry(pPar,set);     // in base class
  }
  printInfo("MdcGeomPar: module(s) initialized from Oracle: ");
  return allFound;    
} 
 

Bool_t HMdcParOraIo::readModGeomNames(HMdcGeomPar* pPar,Int_t* set) {
  // reads the mdc_pos_id of all modules
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int mdc[MDC_MAXMODS];
      int sec[MDC_MAXMODS];
      int pla[MDC_MAXMODS];
      varchar oname[MDC_MAXMODS][9];
    } mods;
    struct {
      short mdc_Ind[MDC_MAXMODS];
      short sec_Ind[MDC_MAXMODS];
      short pla_Ind[MDC_MAXMODS];
      short oname_Ind[MDC_MAXMODS];
    } mods_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readModGeomNames()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL SELECT mdc_hwobj_id, sector, plane, geom_obj
    INTO :mods
    FROM mdc_ana.mdc_loc_at_run;

  Int_t nMods=sqlca.sqlerrd[2];
  Int_t pos, s, m;
  char ref[10];
  Bool_t allFound=kTRUE;
  initModules->Reset();
  for(Int_t i=0;i<nMods;i++) {
    s=mods.sec[i]-1;
    m=mods.pla[i]-1;
    HModGeomPar* pMod=pPar->getModule(s,m);
    pos=s*4 + m;
    if (pMod && set[pos]) {
      if (mods_Ind.oname_Ind[i]!=-1) {
        mods.oname[i].arr[mods.oname[i].len]='\0';
        pMod->SetName((char*)(mods.oname[i].arr));
        initModules->AddAt(pos+1,pos);
        set[i]=0;
        strcpy(ref,(char*)(mods.oname[i].arr));
        ref[4]='1'; // reference module in sector 1
                    // not yet introduced in database
        pMod->setRefName(ref);
        Int_t mr=pPar->getModNumInMod(ref);
        HGeomCompositeVolume* refMod=pPar->getRefVolume(mr);
        if (refMod==0) {
          refMod=new HGeomCompositeVolume(pPar->getNumComponents());
          refMod->SetName(ref);
          pPar->addRefVolume(refMod,mr);
        }
        pMod->setVolume(refMod);
      }
    }
  } 
  for(Int_t i=0;i<MDC_MAXMODS;i++) {
    if (set[i]==1 && initModules->At(i)==0) allFound=kFALSE;
  }
  return allFound; 
} 
 

Bool_t HMdcParOraIo::readLayerGeomNames(HMdcGeomPar* pPar,Int_t* set) {
  // reads the names of all layers in the geometry tables
  Int_t nLayers=-1, pos;
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    struct {
      int lay[MDC_MAXLAYS];
      varchar oname[MDC_MAXLAYS][9];
    } layers;
    struct {
      short lay_Ind[MDC_MAXMODS];
      short oname_Ind[MDC_MAXMODS];
    } layers_Ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("readLayerGeomNames(...)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL DECLARE c7 CURSOR FOR
    SELECT layer_nr, layer_name
    FROM mdc_ana.mdclayerparam
    WHERE mdc_hwobj_id=:id;

  Bool_t allFound=kTRUE;
  for(Int_t i=0;i<6;i++) {
    for(Int_t j=0;j<4;j++) {
      HModGeomPar* pMod=pPar->getModule(i,j);
      pos=i*4+j;
      if (set[pos] && pMod) {
        HGeomCompositeVolume* pRefMod=pMod->getRefVolume();
        id=mdcIds->At(pos);
        if (id>0) {
          EXEC SQL OPEN c7;
          EXEC SQL FETCH c7 INTO :layers;
          nLayers=sqlca.sqlerrd[2];
          if (nLayers!=MDC_MAXLAYS) allFound=kFALSE;
          for(Int_t k=0;k<nLayers;k++) {
            if (layers_Ind.oname_Ind[k]!=-1) {
              layers.oname[k].arr[layers.oname[k].len]='\0';
              HGeomVolume* volu=pRefMod->getComponent((layers.lay[k]-1));
              volu->SetName((char*)(layers.oname[k].arr));
            }
          }
          EXEC SQL CLOSE c7; 
        }
      }
    }
  }
  return allFound;    
}

 
void HMdcParOraIo::printInfo(Text_t* msg) {
  // prints the modules initialized from Oracle
  // will later go to the log file
  Bool_t first=kTRUE;
  for(Int_t i=0;i<MDC_MAXMODS;i++) {
    if (initModules->At(i)) {
      if (first) {
        cout<<msg;
        first=kFALSE;
      }
      cout<<(initModules->At(i)-1)<<" ";
    }
  }
  cout<<'\n';
}


Int_t HMdcParOraIo::getCal1parVersion(Int_t version) {
  // reads the newest version number for the calibration parameters
  // valid for the current event file
  if (!cal1parVersions) cal1parVersions=new TArrayI(modIds->GetSize());
  if (!cal1parDate) cal1parDate=new Double_t[2];
  else {
    if (version!=-1 && runStart>=cal1parDate[0] && runStart<=cal1parDate[1])
      return version;
  }
  clearVersDate(cal1parDate);
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int mdc[MDC_MAXMODS];
      int vers[MDC_MAXMODS];
      double since[MDC_MAXMODS];
      double until[MDC_MAXMODS];
    } mods;
  EXEC SQL END DECLARE SECTION;
  Int_t nMods=0;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getCal1parVersion(Int_t)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT mdc_hwobj_id, cal1_par_vers_id,
                  hdate.to_ansitime(valid_since),
                  hdate.to_ansitime(valid_until)
           INTO :mods
           FROM mdc_ana.cal1_par_mod_vers_at_run;
  nMods=sqlca.sqlerrd[2];
  for(Int_t i=0;i<nMods;i++) {
    Int_t m=mods.mdc[i];
    if (modIds->At(m)>0) {
      cal1parVersions->AddAt(mods.vers[i],m);
      if (i==0) {
        cal1parDate[0]=mods.since[i];
        cal1parDate[1]=mods.until[i];
      } else {
        cal1parDate[0]=(mods.since[i]>cal1parDate[0]) ? mods.since[i]
                                                      : cal1parDate[0];
        cal1parDate[1]=(mods.until[i]<cal1parDate[1]) ? mods.until[i]
                                                      : cal1parDate[1];
      }
    }
  }
  if (cal1parDate[0]>0) return getActRunId();
  return -1;  
}; 


Bool_t HMdcParOraIo::read(HMdcCalParRaw* pPar, Int_t* set) {
  // reads the calibration parameters and fill the MdcCalParRaw container
  Int_t version=getPredefVersion(pPar);
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if (version==-1) version=getCal1parVersion(contVers);
  if (version==-1) return kFALSE;
  if (contVers==version) return kTRUE;
  pPar->setInputVersion(version,inputNumber);
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int vers;
    struct {
      int mbo[MDC_MAXCHAN];
      int tdc[MDC_MAXCHAN];
      int chan[MDC_MAXCHAN];
      float sl[MDC_MAXCHAN];
      float sE[MDC_MAXCHAN];
      float sM[MDC_MAXCHAN];
      float o[MDC_MAXCHAN];
      float oE[MDC_MAXCHAN];
      float oM[MDC_MAXCHAN];
    } cal;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HMdcCalParRaw*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE c8 CURSOR FOR
    SELECT mbo_local_pos_id, tdc_nr, tdc_chan, slope, slope_err,
           slope_cal_method, offset, offset_err, offset_cal_method
      FROM mdc_ana.tdc_channel c, mdc_ana.cal1_par p
      WHERE c.mdc_hwobj_id = :id
        AND c.tdc_channel_id = p.tdc_channel_id
        AND p.cal1_par_vers_id =:vers
        ORDER BY mbo_local_pos_id;
  Bool_t allFound=kTRUE;
  initModules->Reset();
  HMdcCalParRaw& mdc=*pPar;
  Int_t pos;
  for(Int_t i=0;i<6;i++) {
    HMdcCalParRawSec& sec=mdc[i];
    for(Int_t j=0;j<4;j++) {
      HMdcCalParRawMod& mod=sec[j];
      pos=i*4+j;
      if (set[pos]) {
        id=mdcIds->At(pos);
        vers=cal1parVersions->At(id);
        if (id>0 && vers>0) {
          EXEC SQL OPEN c8;
          EXEC SQL FETCH c8 INTO :cal;
          Int_t nChannels=-1, mo, mm=-1, mi=-1, ch;
          nChannels=sqlca.sqlerrd[2];
          for(Int_t k=0;k<nChannels;k++) {
            mo=cal.mbo[k];
            if (mo>mm) {
              mi++;
              const char* mboName=mod[mi].GetName();
              sscanf(mboName,"%i",&mm);
              if (mo!=mm) {
                Error("read(HMdcCalParRaw*,Int_t*)",
                      "MBO %i is missingin parameter container",mm);
                EXEC SQL CLOSE c8;
                return kFALSE;
              }
              mm=mo;
            }
            ch=(cal.tdc[k]-1)*8 + cal.chan[k] - 1;
            mod[mi][ch].fill(cal.sl[k],cal.o[k],
                             cal.sE[k],cal.oE[k],
                             cal.sM[k],cal.oM[k]);
          }
          if (nChannels>0) {
            set[pos]=0;
            initModules->AddAt(pos+1,pos);
          }
          else allFound=kFALSE;
         }
        else allFound=kFALSE;
      }
    }
  }
  EXEC SQL CLOSE c8;
  pPar->setChanged();
  printInfo("MdcCalParRaw: module(s) initialized from Oracle: ");
  return allFound;
}; 


Int_t HMdcParOraIo::writePar(HMdcCalParRaw* pPar) {
  // creates a new version and writes the calibration parameters to Oracle
  Int_t version=createCal1parVers(pPar);
  if (version==-1) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int mdc[MDC_MAXCHAN];
    int mbo[MDC_MAXCHAN];
    int tdc[MDC_MAXCHAN];
    int chan[MDC_MAXCHAN];
    int vers[MDC_MAXCHAN];
    float sl[MDC_MAXCHAN];
    float sE[MDC_MAXCHAN];
    float sM[MDC_MAXCHAN];
    float o[MDC_MAXCHAN];
    float oE[MDC_MAXCHAN];
    float oM[MDC_MAXCHAN];
    int rows_to_insert;
  EXEC SQL END DECLARE SECTION;
  Int_t id, pos, mboInd;
  for(Int_t s=0; s<pPar->getSize(); s++) {
    HMdcCalParRawSec& rSec= (*pPar)[s];
    for(Int_t m=0; m<rSec.getSize(); m++) {
      HMdcCalParRawMod& rMod= rSec[m];
      pos=s*4+m;
      id=mdcIds->At(pos);
      if (id>0) {
        Int_t nChan=0;
        for(Int_t l=0; l<rMod.getSize(); l++) {
          HMdcCalParMbo& rMbo= rMod[l];
          const char* mboName=rMbo.GetName();
          sscanf(mboName,"%i",&mboInd);
          for(Int_t c=0; c<rMbo.getSize(); c++) {
            HMdcCalParTdc& ch= rMbo[c];
            Int_t tN=(Int_t)(c/8);
            Int_t cN=c-tN*8;
            mdc[nChan]=id;
            mbo[nChan]=mboInd;
            tdc[nChan]=tN+1;
            chan[nChan]=cN+1;
            sl[nChan]=ch.getSlope();
            sE[nChan]=ch.getSlopeErr();
            sM[nChan]=ch.getSlopeMethod();
            o[nChan]=ch.getOffset();
            oE[nChan]=ch.getOffsetErr();
            oM[nChan]=ch.getOffsetMethod();
            vers[nChan]=version;
            nChan++;
          }
        }
        if (nChan==0) continue;
        rows_to_insert=nChan;
        Int_t nChanO=countTdcChannels(id);
        if (nChan!=nChanO) {
          Error("writePar(HMdcCalParRaw*)",
                "\n Number of Tdc channels in Oracle:        %i\n Number of Tdc channels in MdcCalParRaw:  %i\n",
                nChanO,nChan);
          rollback();
          return -1;
        }
        EXEC SQL WHENEVER SQLERROR GOTO not_found;
        EXEC SQL WHENEVER NOT FOUND GOTO not_found;
        EXEC SQL FOR :rows_to_insert
          INSERT INTO mdc_ana.cal1_par (tdc_channel_id, cal1_par_vers_id,
                                slope, slope_err, slope_cal_method,
                                offset, offset_err, offset_cal_method)
            VALUES (mdc_ana.cal1_par_query.get_tdc_Chan_id(:mdc,:mbo,:tdc,:chan),
                    :vers, :sl, :sE, :sM, :o, :oE, :oM);
        cout<<"mdc_hwobj_id: "<<id<<"    "<<rows_to_insert<<" rows inserted\n";
      }
    }
  }
  commit();
  pPar->setChanged(kFALSE);
  return version;
not_found:
  showSqlError("writePar(HMdcCalParRaw*)");
  rollback();
  return -1;
}
 
Int_t HMdcParOraIo::createCal1parVers(HMdcCalParRaw* pPar) {
  // creates a new version for the calibration parameters
  // return the new version
  if (author.IsNull()) {
    Error("createCal1parVers(...)",
          "author of calibration parameters not defined");
    return -1;
  }
  if (description.IsNull()) {
    Error("createCal1parVers(...)",
          "descriction of calibration parameters not defined");
    return -1;
  }
  if (runsUsed.IsNull()) {
    Error("createCal1parVers(...)",
          "runs used for calibration parameters not defined");
    return -1;
  }
  EXEC SQL BEGIN DECLARE SECTION;
    char* creator;
    char* descript;
    char* runs;
    int vers=-1;
  EXEC SQL END DECLARE SECTION;
  creator=(char*)author.Data();
  descript=(char*)description.Data();
  runs=(char*)runsUsed.Data();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  EXEC SQL EXECUTE
    BEGIN
      INSERT INTO mdc_ana.cal1_par_vers (author, descr, runs_used)
        VALUES (:creator, :descript, :runs);
      SELECT mdc_ana.cal1_par_query.get_curr_version INTO :vers FROM DUAL;
    END;
  END-EXEC;
  cout<<"Oracle: version cal1_par_vers_id "<<vers<<" created\n";
  return vers;
not_found:
  showSqlError("createCal1parVers(HMdcCalParRaw*)");
  return vers;
} 

Int_t HMdcParOraIo::countTdcChannels(Int_t mdc) {
  // returns the number of TDC channels of a module
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int num;
  EXEC SQL END DECLARE SECTION;
  id=mdc;
  EXEC SQL WHENEVER SQLERROR DO
    showSqlError("countTdcChannels(Int_t)");
  EXEC SQL WHENEVER NOT FOUND GOTO notfound;
  EXEC SQL SELECT COUNT(tdc_channel_id) INTO :num
           FROM mdc_ana.tdc_channel WHERE mdc_hwobj_id=:id;
  return num;
notfound:
  return 0;
}

void HMdcParOraIo::resetComments(void) {
  // resets the comments used to create a new version
  author="";
  description="";
  runsUsed="";
}

void HMdcParOraIo::clearVersDate(Double_t* p) {
  // creates a date range array
  p[0]=-1;
  p[1]=-1;
}

