//*-- AUTHOR : Ilse Koenig
//*-- Created : 26/09/2002 by Ilse Koenig
//*-- Modified: 04/02/2003 by Ilse Koenig

//////////////////////////////////////////////////////////////////////////////
//
// HOraSimRunStorage
//
// Class to storage HGEANT simulations runs in Oracle
//
//////////////////////////////////////////////////////////////////////////////

using namespace std;
#include "horasimrunstorage.h"
#include "horasimrun.h"
#include "horasimrunconfig.h"
#include "horasimutil.h"
#include "TList.h"
#include <iostream>
#include <iomanip>
#include <fstream>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern

// Oracle communication area
#include <oraca.h>
// Include the SQL Communications Area
#include <sqlca.h>

ClassImp(HOraSimRunStorage)

HOraSimRunStorage::HOraSimRunStorage(HOraSimUtil* p) {
  pUtil=p;
  project="";
  subProject="";
  projectId=-1;
  runs=new TList;
}  

HOraSimRunStorage::~HOraSimRunStorage() {
  if (runs) {
    runs->Delete();
    delete runs;
    runs=0;
  }
}

void HOraSimRunStorage::print() {
  TIter next(runs);
  HOraSimRun* o;
  while ((o=(HOraSimRun*)next())!=0) {
    o->print();
  }  
}

Bool_t HOraSimRunStorage::readAllFromFile(const char* filename) {
  Bool_t rc=kTRUE;
  fstream* fin=new fstream;
  fin->open(filename,ios::in);
  if (fin && fin->rdbuf()->is_open()==1) {
    const Int_t maxbuf=1024;
    Text_t buf[maxbuf];
    TString s, pName, pVal, geantVersion, hydraVersion, rootVersion,
            cernLib, compiler, author, description;
    Int_t generation;
    while (!fin->eof() && rc) {
      fin->getline(buf,maxbuf);
      s=buf;
      s=s.ReplaceAll("\t"," ");
      s.Strip(s.kBoth);
      if (s.Length()!=0 && !s.BeginsWith("//")) {
        Ssiz_t n=s.First(':');
        if (n==-1) {
          Error("readFromFile",
                "Missing backslash for keyword %s",pName.Data());
          rc=kFALSE;
          break;
        }
        Ssiz_t m=s.Last('\\');
        pName=s(0,n);
        pName.ToLower();
        if (m>0) s=s(n+1,m-n-1);
        else s=s(n+1,s.Length()-n-1);
        if (pName.CompareTo("simul runs")==0) {
          if (s.Length()>0)
            rc=readRunFromFile(s.Data(),generation,geantVersion,hydraVersion,
                               rootVersion,cernLib,compiler,author,description);
          while (!fin->eof() && rc) {
            fin->getline(buf,maxbuf);
            s=buf;
            s=s.ReplaceAll("\t"," ");
            s.Strip(s.kBoth);
            if (s.Length()!=0 && !s.BeginsWith("//"))
            rc=readRunFromFile(s.Data(),generation,geantVersion,hydraVersion,
                               rootVersion,cernLib,compiler,author,description);
          }
        } else {
          s=s.Strip(s.kLeading);
          pVal=s;
          if (m>0) pVal+="\n";
          while (m>0 && !fin->eof()) {
            fin->getline(buf,maxbuf);
            s=buf;
            s=s.ReplaceAll("\t"," ");
            s.Strip(s.kBoth);
            if (s.Length()!=0 && !s.BeginsWith("//")) {
              m=s.Last('\\');
              if (m>0) {
                pVal+=s(0,m);
                pVal+="\n";
              }
              else pVal+=s;
            }
          }
          if (pName.CompareTo("generation")==0) sscanf(pVal.Data(),"%i",&generation);
          if (pName.CompareTo("geant version")==0) geantVersion=pVal;
          if (pName.CompareTo("hydra version")==0) hydraVersion=pVal;
          if (pName.CompareTo("root version")==0) rootVersion=pVal;
          if (pName.CompareTo("cern lib")==0) cernLib=pVal;
          if (pName.CompareTo("compiler")==0) compiler=pVal;
          if (pName.CompareTo("author")==0) author=pVal;
          if (pName.CompareTo("description")==0) description=pVal;
        }
      }
    }
    fin->close();
  } else {
    Error("readAllFromFile(const char*)","No File open");
    rc=kFALSE;
  }
  delete fin;
  return rc;
}

Bool_t HOraSimRunStorage::readRunFromFile(const char* s,Int_t generation,
                          TString& geantVersion,TString& hydraVersion,
                          TString& rootVersion,TString& cernLib,
                          TString& compiler,TString& author,
                          TString& description) {
  HOraSimRun* run=new HOraSimRun;
  HOraSimRunConfig* config=run->getConfig();
  config->setGeneration(generation);
  config->setGeantVersion(geantVersion.Data());
  config->setHydraVersion(hydraVersion.Data());
  config->setRootVersion(rootVersion.Data());
  config->setCernLib(cernLib.Data());
  config->setCompiler(compiler.Data());
  config->setAuthor(author.Data());
  config->setDescription(description.Data());
  char fName[128], fDir[128], fSize[30], nevents[30],
       created[50], creaTime[30], configFile[256];
  sscanf(s,"%s%s%s%s%s%s%s",
         fName,fDir,created,creaTime,fSize,nevents,configFile);
  run->setFileName(fName);
  run->setFileDirectory(fDir);
  run->setFileSize(fSize);
  strcat(created," ");
  strcat(created,creaTime);
  run->setCreationDate(created);
  run->setNEvents(nevents);
  // read and decode config file
  Bool_t rc=kTRUE;
  fstream* fin=new fstream;
  fin->open(configFile,ios::in);
  if (fin && fin->rdbuf()->is_open()==1) {
    const Int_t maxbuf=1024;
    Text_t buf[maxbuf];
    TString s, ss, geantFlags, parameters, eventFile, rootFile;
    Float_t fieldFac;
    Int_t runId, j;
    Bool_t geantFlagsRead=kFALSE, first=kTRUE;
    while (!fin->eof() && rc) {
      fin->getline(buf,maxbuf);
      s=buf;
      s.Strip(s.kBoth);
      if (s.Length()!=0 && !s.BeginsWith("//")) {
        if (!geantFlagsRead) {
          if (s.BeginsWith("END")) {
            geantFlagsRead=kTRUE;
            first=kTRUE;
          } else {
            if (s.BeginsWith("RUNG")) {
              Int_t i=s.First("!");
              if (i>0) ss=s(4,i-4);
              else ss=s(4,s.Length()-4);
              sscanf(ss.Data(),"%i %i",&runId,&j);
            } else {
              if (!first) geantFlags.Append("\n");
              else first=kFALSE;
              geantFlags.Append(s);
              if (s.BeginsWith("FPOL")) {
                Int_t i=s.First("!");
                if (i>0) ss=s(4,i-4);
                else ss=s(4,s.Length()-4);
                sscanf(ss.Data(),"%f",&fieldFac);
              }
            }
          }
        } else {
          if (s.Contains(".evt")) eventFile=s;
          else {
            if (s.Contains(".root")) {
              Int_t l=s.Last('/')+1;
              rootFile=s(l,s.Length()-l);
            } else {
              parameters.Append(s);
              parameters.Append("\n");
            }
          }
        }
      }
    }
    fin->close();
    config->setGeantFlags(geantFlags.Data());
    config->setParameters(parameters.Data());
    run->setRunId(runId);
    run->setEventFile(eventFile);
    Int_t i=rootFile.Last('.');
    TString runFile(fName);
    Int_t k=runFile.Last('.');
    ss=runFile(i,k-i);
    Int_t n;
    sscanf(ss.Data(),"%i",&n);
    run->setFileNum(n);
  } else {
     Error("readFromFile(const char*)","No File open");
     rc=kFALSE;
  }
  delete fin;
  runs->Add(run);
  return kTRUE;
}

Int_t HOraSimRunStorage::getProjectId() {
  if (project.IsNull()) {
    Error("getProjectId()",
          "Project not defined");
    return -1;
  }
  if (subProject.IsNull()) {
    Error("getProjectId()",
          "Sub-Project not defined");
    return -1;
  }
  EXEC SQL BEGIN DECLARE SECTION;
    int id=-1;
    char* proj;
    char* subproj;
  EXEC SQL END DECLARE SECTION;
  proj=(char*)project.Data();
  subproj=(char*)subProject.Data();
  EXEC SQL WHENEVER SQLERROR GOTO ErrorFound;
  EXEC SQL WHENEVER NOT FOUND GOTO NotFound;
  EXEC SQL SELECT project_id INTO :id
           FROM hanal.simul_project
           WHERE exp_id = :proj AND sub_project = :subproj;
  return id;
NotFound:
  Error("getProjectId()",
        "Project or sub_project not found");
  return -1;    
ErrorFound:
   pUtil->showSqlError("HOraSimRunStorage::getProjectId()");
  return -1;    
}    

Bool_t HOraSimRunStorage::store() {
  if (projectId==-1) projectId=getProjectId();
  if (projectId==-1) return kFALSE;
  HOraSimRunConfig *lastProjectConfig=new HOraSimRunConfig;
  Int_t configId=readLastConfig(projectId,lastProjectConfig);
  HOraSimRunConfig *lastConfig=0, *currConfig;
  Bool_t configStored=kFALSE, rc=kTRUE;
  if (configId>0) lastConfig=lastProjectConfig;
  TIter next(runs);
  HOraSimRun* o;
  while ((o=(HOraSimRun*)next())!=0 && rc) {
    currConfig=o->getConfig();
    if (lastConfig!=0) {
      configStored=currConfig->compare(*lastConfig);
    }
    if (!configStored) {
      configId=storeConfig(currConfig);
      lastConfig=currConfig;
    } else cout<<"Reuse of Run Configuration "<<configId<<endl;
    if (configId>0) rc=storeRun(o,projectId,configId);
    else rc=kFALSE;
  }
  delete lastProjectConfig;  
  return rc;
}

Int_t HOraSimRunStorage::readLastConfig(Int_t projectId,HOraSimRunConfig* config) {
  if (projectId<=0) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int   project;
    int   id;
    int   gen;
    varchar geantVers[31];
    varchar hydraVers[31];
    varchar rootVers[31];
    varchar cernVers[31];
    varchar comp[81];
    varchar flags[4001];
    varchar params[4001];
    varchar auth[81];
    varchar descript[4001];
    short geantVers_ind;
    short hydraVers_ind;
    short rootVers_ind;
    short cernVers_ind;
    short comp_ind;
    short descript_ind;
  EXEC SQL END DECLARE SECTION;
  project=projectId;
  EXEC SQL WHENEVER SQLERROR GOTO NotFound;
  EXEC SQL WHENEVER NOT FOUND GOTO NotFound;
  EXEC SQL SELECT c.config_id,generation,geant_version,hydra_version,root_version,
                  cern_lib,compiler,geant_flags,parameters,author,description
           INTO   :id,:gen,:geantVers:geantVers_ind,
                  :hydraVers:hydraVers_ind,:rootVers:rootVers_ind,
                  :cernVers:cernVers_ind,:comp:comp_ind,:flags,:params,
                  :auth,:descript:descript_ind
           FROM hanal.simul_run r, hanal.simul_run_config c
           WHERE r.id = ( SELECT MAX(id) from hanal.simul_run
                          WHERE project_id = :project )
             AND c.config_id = r.config_id;
  config->setGeneration(gen);  
  if (geantVers_ind!=-1) {
    geantVers.arr[geantVers.len]='\0';
    config->setGeantVersion((char*)geantVers.arr);
  }
  if (hydraVers_ind!=-1) {
    hydraVers.arr[hydraVers.len]='\0';
    config->setHydraVersion((char*)hydraVers.arr);
  }
  if (rootVers_ind!=-1) {
    rootVers.arr[rootVers.len]='\0';
    config->setRootVersion((char*)rootVers.arr);
  }
  if (cernVers_ind!=-1) {
    cernVers.arr[cernVers.len]='\0';
    config->setCernLib((char*)cernVers.arr);
  }
  if (comp_ind!=-1) {
    comp.arr[comp.len]='\0';
    config->setCompiler((char*)comp.arr);
  }
  flags.arr[flags.len]='\0';  
  config->setGeantFlags((char*)flags.arr);
  params.arr[params.len]='\0';  
  config->setParameters((char*)params.arr);
  auth.arr[auth.len]='\0';  
  config->setAuthor((char*)auth.arr);
  if (descript_ind!=-1) {
    descript.arr[descript.len]='\0';
    config->setDescription((char*)descript.arr);
  }
  return id;
NotFound:
  return -1;
}

Int_t HOraSimRunStorage::storeConfig(HOraSimRunConfig* config) {
  EXEC SQL BEGIN DECLARE SECTION;
    int id =-1;
    int   gen;
    char* geantVers;
    char* hydraVers;
    char* rootVers;
    char* cernVers;
    char* comp;
    char* flags;
    char* params;
    char* auth;
    char* descript;
    short geantVers_ind;
    short hydraVers_ind;
    short rootVers_ind;
    short cernVers_ind;
    short comp_ind;
    short descript_ind;
  EXEC SQL END DECLARE SECTION;
  gen=config->getGeneration();
  geantVers=(char*)config->getGeantVersion();
  geantVers_ind=(strlen(geantVers)==0) ? -1 : 0;
  hydraVers=(char*)config->getHydraVersion();
  hydraVers_ind=(strlen(hydraVers)==0) ? -1 : 0;
  rootVers=(char*)config->getRootVersion();
  rootVers_ind=(strlen(rootVers)==0) ? -1 : 0;
  cernVers=(char*)config->getCernLib();
  cernVers_ind=(strlen(cernVers)==0) ? -1 : 0;
  comp=(char*)config->getCompiler();
  comp_ind=(strlen(comp)==0) ? -1 : 0;
  flags=(char*)config->getGeantFlags();
  if (strlen(flags)==0) {
    Error("storeConfig()",
          "Geant flags not defined");
    return -1;
  }
  params=(char*)config->getParameters();
  if (strlen(params)==0) {
    Error("storeConfig()",
          "Configuration parameters not defined");
    return -1;
  }
  auth=(char*)config->getAuthor();
  if (strlen(auth)==0) {
    Error("storeConfig()",
          "author of simulation not defined");
    return -1;
  }
  descript=(char*)config->getDescription();
  descript_ind=(strlen(descript)==0) ? -1 : 0;
  EXEC SQL WHENEVER SQLERROR GOTO ErrorFound;
  EXEC SQL WHENEVER NOT FOUND GOTO ErrorFound;
  EXEC SQL EXECUTE
    DECLARE
    BEGIN
      :id := hanal.simul_run_query.next_sim_sequ_id;
      IF :id > 0 THEN
        INSERT INTO hanal.simul_run_config
            (config_id,generation,geant_version,hydra_version,root_version,
             cern_lib,compiler,geant_flags,parameters,
             author,description)
          VALUES(:id,:gen,:geantVers:geantVers_ind,
             :hydraVers:hydraVers_ind,:rootVers:rootVers_ind,
             :cernVers:cernVers_ind,:comp:comp_ind,:flags,:params,
             :auth,:descript:descript_ind);
      END IF;
    END;
  END-EXEC;
  cout<<"Run Configuration "<<id<<" stored in Oracle"<<endl;
  return id;
ErrorFound:
  pUtil->showSqlError("storeConfig()");
  pUtil->rollback();
  return -1;
}

Bool_t HOraSimRunStorage::storeRun(HOraSimRun* run,Int_t projectId,
                                   Int_t configId) {
  EXEC SQL BEGIN DECLARE SECTION;
    int project;
    int config;
    int rid;
    int fnum;
    char* fname;
    char* fdir;
    int fsize;
    int nevts;
    char* ftime;
    char* evtfile;
    int evtid=-1;
  EXEC SQL END DECLARE SECTION;
  project=projectId;
  config=configId;
  rid=run->getRunId();
  fnum=run->getFileNum();
  fname=(char*)run->getFileName();
  if (strlen(fname)==0) {
    Error("storeRun()","filename not defined");
    return kFALSE;
  }
  fdir=(char*)run->getFileDirectory();
  if (strlen(fdir)==0) {
    Error("storeRun()","file directory not defined");
    return kFALSE;
  }
  fsize=run->getFileSize();
  nevts=run->getNEvents();
  ftime=(char*)run->getCreationDate();
  if (strlen(ftime)==0) {
    Error("storeRun()","file creation date not defined");
    return kFALSE;
  }
  evtfile=(char*)run->getEventFile();
  if (strlen(evtfile)==0) {
    Error("storeRun()","event file not defined");
    return kFALSE;
  }
  EXEC SQL WHENEVER SQLERROR GOTO ErrorFound;
  EXEC SQL WHENEVER NOT FOUND GOTO ErrorFound;
  EXEC SQL EXECUTE
    DECLARE
    BEGIN
      :evtid := hanal.simul_run_query.eventfile_id(:evtfile);
      IF :evtid > 0 THEN
        INSERT INTO hanal.simul_run
            ( run_id, file_num, project_id, event_file_id, config_id,
              file_name, file_location, file_size, events, created )
        VALUES ( :rid, :fnum, :project, :evtid, :config,
              :fname, :fdir, :fsize, :nevts, hdate.char_to_date(:ftime));
      END IF;
    END;
  END-EXEC;
  if (evtid>0) {
    cout<<"Run "<<fdir<<"/"<<fname<<" stored in Oracle"<<endl;
    pUtil->commit();
    return kTRUE;
  }
  Error("storeRun()","Event file %s for run %s/%s not found",
        evtfile,fdir,fname);
  pUtil->rollback();
  return kFALSE;
ErrorFound:
  pUtil->showSqlError("storeRun()");
  pUtil->rollback();
  return kFALSE;
}