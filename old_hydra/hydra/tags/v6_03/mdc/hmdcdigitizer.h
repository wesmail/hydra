#ifndef HMDCDITIZER_H
#define HMDCDITIZER_H

#include "hreconstructor.h"
#include "hcategory.h"
#include "TRandom.h"
#include "TNtuple.h"
#include "iostream.h"
#include "hlocation.h"

class HIterator;
class HMdcLayerGeomPar;
class HMdcDigitPar;
class HMdcCal2ParSim;
class HMdcCal1Sim;
class HMdcCellEff;
class HMdcGeantCell;
class TFile;

class HMdcDigitizer : public HReconstructor {
private:
  HCategory* fGeantMdcCat;         //! MDC HGeant input data
  HLocation loc;                   // Location for new object
  HLocation locnoise;              // Location for new object

  HCategory* fGeantCellCat;        // Pointer to sim data category
  HCategory* fCalCat;              // Pointer to cal data category
  HMdcGeantCell* hit;              // Pointer to HMdcGeantCell hit
  HMdcLayerGeomPar* fDigitGeomPar; // Digitisation "geom" parameters
  HMdcDigitPar* fDigitPar;         // Digitisation "phys" parameters
  HMdcCal2ParSim* fCal2ParSim;     // pointer to cal2 parameter container
  HMdcCellEff* fCellEff;           // pointer to cell efficiency parameter container
  HMdcCal1Sim* fCal;               // pointer to data
  HMdcCal1Sim* fCalnoise;           // pointer to noise data
  HMdcGeantCell* fCell;            // pointer to Container for HMdcGeantCell
  HIterator* iterin;               // Iterator over input category
  HIterator* itercell;             // Iterator over cell category
  Int_t fEventId;                  // Number of current event
  Float_t yDist;                   // Distance to the sence wire
  Float_t pi;                      // Il y quatre pis a une vache

  Int_t modetdc;                   // 2 leading edges or leading and trailing edge of the signal
  Int_t setup[6][4];               // setup of Mdc (sec,mod)

  Float_t time1;         // drift time1 calculated by HMdcCal2ParSim
  Float_t time1Error;    // drift time1 error calculated by HMdcCal2ParSim
  Float_t time2;         // drift time2 calculated by HMdcCal2ParSim
  Float_t time2Error;    // drift time2 error calculated by HMdcCal2ParSim
  Float_t myalpha;       // impact angle of the track in coordinate system of HMdcCal2ParSim

  TFile *myoutput;       // file pointer for NTuple
  TNtuple *distance_time;// nTuple for internal information of the digitizer
  Bool_t fntuple;        // switch for use/not use NTuple

  Bool_t useTof;         // switch for use/not use of tof in output
  Float_t offsets[4];    // offsets are used to substract min tof
  Bool_t useOffsets;     // switch for use/not use offset substraction in output

  Float_t effLevel[4];   // level of requiered maximum charge to create a signal (for example 20 (=20%))
  Bool_t useCellEff;     // switch for use/not use cell efficiency cut

  Float_t noiseLevel[4]; // level of randon noise for each module type
  Bool_t useNoise;       // switch for use/not use of noise generator
  Int_t arrayNoise[5];   // temp array for status of noise
  Int_t noiseRangeLo[4]; // lower range of noise for each mdc type
  Int_t noiseRangeHi[4]; // upper range of noise for each mdc type
  Float_t time1noise;    // time1 generated by the noise generator
  Float_t time2noise;    // time2 generated by the noise generator
  Int_t noisemode;       // switch for different noise modes
  Int_t firstHit;        // number of first valid hit
  Int_t secondHit;       // number of second valid hit
  Float_t firstTime2;    // time2 of first valid hit
  Int_t endList1;        // end of the list of hits belonging to the first valid hit
  Int_t firstsec;
  Int_t firstmod;
  Int_t firstlay;
  Int_t firstcell;

  static  Float_t dTime [15];       // drift time1 + tof
  static  Float_t dTime2[15];       // drift time2 + tof
  static  Float_t dTimeErr [15];    // error of drift time1
  static  Float_t dTime2Err[15];    // error of drift time2
  static  Float_t minimumdist[15];  // minimum distance to wire
  static  Int_t track[15];          // track numbers
  static  Float_t timeOfFlight[15]; // tof
  static  Float_t angle[15];        // impact angle in coordinate system of the cell
  static  Int_t statusflag[15];     // flag for efficiency
  static  Bool_t cutEdge[15];     // flag for efficiency

public:
  HMdcDigitizer(void);
  HMdcDigitizer(Text_t* name,Text_t* title);
  HMdcDigitizer(Text_t* name,Text_t* title,Int_t,Bool_t);
  ~HMdcDigitizer(void);
  void setOffsets(Float_t off0,Float_t off1,Float_t off2,Float_t off3)
  {
      useOffsets=kTRUE;
      offsets[0] =off0;
      offsets[1] =off1;
      offsets[2] =off2;
      offsets[3] =off3;
  }
  void setEffLevel(Float_t eff0,Float_t eff1,Float_t eff2,Float_t eff3)
  {
      useCellEff=kTRUE;
      effLevel[0] =100-eff0;
      effLevel[1] =100-eff1;
      effLevel[2] =100-eff2;
      effLevel[3] =100-eff3;
  }
  void setNoiseLevel(Float_t noise0,Float_t noise1,Float_t noise2,Float_t noise3)
  {
      useNoise=kTRUE;
      noiseLevel[0] =1-(noise0*0.01);
      noiseLevel[1] =1-(noise1*0.01);
      noiseLevel[2] =1-(noise2*0.01);
      noiseLevel[3] =1-(noise3*0.01);
  }

  void setNoiseRange(Int_t rangeLo0,Int_t rangeLo1,Int_t rangeLo2,Int_t rangeLo3,
		     Int_t rangeHi0,Int_t rangeHi1,Int_t rangeHi2,Int_t rangeHi3)
  {
      noiseRangeLo[0] =rangeLo0;
      noiseRangeLo[1] =rangeLo1;
      noiseRangeLo[2] =rangeLo2;
      noiseRangeLo[3] =rangeLo3;
      noiseRangeHi[0] =rangeHi0;
      noiseRangeHi[1] =rangeHi1;
      noiseRangeHi[2] =rangeHi2;
      noiseRangeHi[3] =rangeHi3;
  }

  void setTofUse(Bool_t use)   {useTof=use;}
  void setNTuple(Bool_t ntuple){fntuple=ntuple;}
  void setTdcMode(Int_t mode)  {modetdc=mode;}
  void setNoiseMode(Int_t mode){noisemode=mode;}
protected:
  Bool_t init(void);
  void setParContainers();
  void printStatus();
  Int_t execute(void);
  Bool_t finalize();
  Bool_t transform(Float_t,Float_t,Float_t,Float_t,Float_t,Int_t);
  void storeCell(Float_t,Float_t,Float_t,Int_t,Bool_t);
  void select(Int_t);
  void fillNoise(Int_t, Int_t, Int_t, Int_t,Int_t, Int_t, Int_t, Int_t);
  Float_t fillTime1Noise(Int_t);
  void fillNoiseToGeantCells(Int_t);
  void HMdcDigitizer::fillNTuple(Int_t ,Int_t ,Int_t ,Int_t , Int_t,
			       HMdcGeantCell* ,TNtuple*);
  void fillNTuple(Int_t, Int_t, Int_t, Int_t, Float_t, Float_t, Int_t);
  void setNTuples(void);
  void initArrays(){
      for(Int_t i=0;i<15;i++)   // reset arrays
      {
	  dTime [i]=0.;
	  dTime2[i]=0.;
	  dTimeErr [i]=0.;
	  dTime2Err[i]=0.;
	  minimumdist[i]=0.;
	  track[i]=-99;
	  timeOfFlight[i]=0.;
	  angle[i]=0.;
	  statusflag[i]=0;
          cutEdge[i]=kFALSE;
      }
  }
  void fillArrays(Int_t,Int_t,Int_t,HMdcGeantCell*);
  void resetListVariables()
  {
   	setFirstHit(-999);   // number of first valid hit
        setSecondHit(-999);  // number of second valid hit
	setFirstTime2(-999); // time2 of first valid hit
	setEndList1(-999);   // last hit in window of first valid hit
  };
  void setEfficiencyFlags(Int_t,Int_t,Int_t,Int_t);
  void fillTrackList(HMdcCal1Sim*);
  void findFirstValidHit();
  void findSecondValidHit();
  void getMdcSetup();
  Bool_t testMdcSetup(Int_t s, Int_t m);

  void setTime1Noise(Float_t time){time1noise=time;}
  void setTime2Noise(Float_t time){time2noise=time;}
  Float_t getTime1Noise(){return time1noise;}
  Float_t getTime2Noise(){return time2noise;}
  void setFirstHit(Int_t hit1){firstHit=hit1;}
  void setSecondHit(Int_t hit2){secondHit=hit2;}
  void setFirstTime2(Float_t time2){firstTime2=time2;}
  void setEndList1(Int_t end){endList1=end;}
  Int_t getFirstHit(){return firstHit;}
  Int_t getSecondHit(){return secondHit;}
  Float_t getFirstTime2(){return firstTime2;}
  Int_t getEndList1(){return endList1;}
  void setLoopVariables(Int_t s,Int_t m,Int_t l,Int_t c)
  {
      firstsec=s;
      firstmod=m;
      firstlay=l;
      firstcell=c;
  };
  void setDTime1(Int_t i,Float_t time){dTime[i]=time;}
  void setDTime2(Int_t i,Float_t time){dTime2[i]=time;}
  void setDTime1Err(Int_t i,Float_t timeErr){dTimeErr[i]=timeErr;}
  void setDTime2Err(Int_t i,Float_t timeErr){dTime2Err[i]=timeErr;}
  void setMinimumDist(Int_t i,Float_t dist){minimumdist[i]=dist;}
  void setTrackN(Int_t i,Int_t number){track[i]=number;}
  void setTof(Int_t i,Float_t tof){timeOfFlight[i]=tof;}
  void setAngle(Int_t i,Float_t a){angle[i]=a;}
  void setStatus(Int_t i,Int_t stat){statusflag[i]=stat;}
  void setCutEdge(Int_t i,Bool_t cut){cutEdge[i]=cut;}
  Float_t getDTime1(Int_t i){return dTime[i];}
  Float_t getDTime2(Int_t i){return dTime2[i];}
  Float_t getDTime1Err(Int_t i){return dTimeErr[i];}
  Float_t getDTime2Err(Int_t i){return dTime2Err[i];}
  Float_t getMinimumDist(Int_t i){return minimumdist[i];}
  Int_t   getTrackN(Int_t i){return track[i];}
  Float_t getTof(Int_t i){return timeOfFlight[i];}
  Float_t getAngle(Int_t i){return angle[i];}
  Int_t   getStatus(Int_t i){return statusflag[i];}
  Bool_t  getCutEdge(Int_t i){return cutEdge[i];}
  Float_t getCellEffLevel(Int_t i){return effLevel[i];}
  Float_t getNoiseLevel(Int_t i){return noiseLevel[i];}
  Float_t getOffset(Int_t i){return offsets[i];}
  Int_t getNoiseRangeHi(Int_t i){return noiseRangeHi[i];}
  Int_t getNoiseRangeLo(Int_t i){return noiseRangeLo[i];}

  ClassDef(HMdcDigitizer,0) // Digitizer of MDC data
};

#endif









