//*-- Author : Peter Zumbruch
//*-- Derived from: Manuel Sanchez
//*-- Modified : 09/10/2001 by P. Zumbruch


////////////////////////////////////////////////////////////////////////////
// HRFIORootSource
//
// This data source can read data from a ROOT file generated by
// HYDRA, this includes both the reconstruction and simulation software.
//
// The data source takes care of instantiating the appropriate classes even
// if they are non-standard. That is, if you have an input file with 
// HMdcHitSim instead of HMdcHit; HRFIORootSource will take care of using
// HMdcHitSim during the analysis.
//
////////////////////////////////////////////////////////////////////////////

#include "hrfiorootsource.h"
#include "hades.h"
#include "hrecevent.h"
#include "heventheader.h"
#include "hpartialevent.h"
#include "hcategory.h"
#include <iostream.h>
#include <limits.h>
#include <unistd.h>
#include <TKey.h>
#include <TRFIOFile.h>
#include "htree.h"

#include "rawapi.h"


ClassImp(HRFIORootSource)

  HRFIORootSource::HRFIORootSource(Bool_t fPers) {
  // if fPers==kFALSE, input cats are suppressed in output
  //Class' constructor.
  fInput=0;
  fEventInFile=0;
  fCursor=0;
  fCurrentRunId=INT_MIN;
  fCurrentRefId=-1;
  fDirectory="";
  fPersistency=fPers;
  fArchive="hades";
}

HRFIORootSource::~HRFIORootSource(void) {
  //Class destructor, it clears the data source.
  Clear();
}

Bool_t HRFIORootSource::init(void) {
  //Initializes the data source connecting the parts of the input tree in
  //the input ROOT file to the event structure used for the analysis. If
  //no event structure has been set by the user, HRFIORootSource::init() will
  //set one taken from the input file.
  Bool_t r=kTRUE;

  if (fEventInFile!=0) {
    //If there is an active event structure
    if (gHades->getCurrentEvent()!=0) { 
      Warning("init","Using user defined event structure");
    } else  gHades->setEvent(fEventInFile); 
    
    if ( fInput!=0) {
      Char_t sl=*(strchr(fInput->GetTitle(),'.')+1);
      switch (sl) {
      case '0' : fSplitLevel=0; break;
      case '1' : fSplitLevel=1; break;
      case '2' : fSplitLevel=2; break;
      default : fSplitLevel=0;
      }
      fInput->SetBranchStatus("*",kFALSE);
      gHades->activateTree(fInput);
      fEntries=fInput->GetEntries();
      if (fCursor >= fEntries) return kFALSE; //Entry not existing
      fInput->GetEvent(fCursor);
      fCurrentRunId=gHades->getCurrentEvent()->getHeader()
	->getEventRunNumber();
      printf("Current Run Id %i\n",fCurrentRunId);
      if (fRefIds.find(fCurrentRunId) != fRefIds.end()) 
	fCurrentRefId=fRefIds[fCurrentRunId];
      else
	fCurrentRefId=-1;

      if (fPersistency==kFALSE) { // set all input categories non-persistent

        for(Int_t i=0;i<16;i++) { // loop over partial events
          HPartialEvent* fPar = 
             ((HRecEvent*)fEventInFile)->getPartialEvent(i<<kBitCategorySize);
          if (fPar) fPar->setPersistency(kFALSE);
        }
      }

      r=kTRUE;
    } else {
      Clear();
      r=kFALSE;
    }
  } else {
    r=kFALSE;
  }
  return r;
}

EDsState HRFIORootSource::getNextEvent(void) {
  //Retrieves next event in the input file.
  Int_t bread=0;

  if (fInput) {
    (*fEventAddr)->clearAll(fSplitLevel);
    if (fCursor<fEntries) {
      bread=fInput->GetEvent(fCursor);
      if (bread == 0) return kDsEndData;
      fCursor++;
      if (gHades->getCurrentEvent()->getHeader()->getId() == kStartEvent) {
	fCurrentRunId=gHades->getCurrentEvent()->getHeader()
	                                       ->getEventRunNumber();
	if (fRefIds.find(fCurrentRunId) != fRefIds.end()) 
	  fCurrentRefId=fRefIds[fCurrentRunId];
	else
	  fCurrentRefId=-1;
	return kDsEndFile;
      }
    } else return kDsEndData;
  } else return kDsError;
  return kDsOk;
}

Bool_t HRFIORootSource::getEvent(Int_t eventN) {
  //Retrieves event in position eventN in the input file, copying the 
  //information to the event structure.
  if (fInput) {
    if (fInput->GetEvent(eventN)>0) return kTRUE;
    else return kFALSE;
  }
  return kFALSE;
}

void HRFIORootSource::Clear(void) {
  //Closes the input file.
  if (fInput) {delete fInput; fInput=0;}
}

void HRFIORootSource::setDirectory(Text_t dirName[]) {
  //Sets the directory where to read files from.
  fDirectory=dirName;
  if (fDirectory[fDirectory.Length()-1] != '/') fDirectory+="/";
}

void HRFIORootSource::setArchive(Text_t archiveName[]) {
  //Sets the archive where to read files from.
  fArchive=archiveName;
}

Bool_t HRFIORootSource::fileExists(const TString &name) {
  //Checks for the existence on one file.
  return (access(name.Data(),F_OK)==0)?kTRUE:kFALSE;
}

Bool_t HRFIORootSource::access(const TString &name, Int_t mode){
  if (mode == 0)
    {
          RFILE *fRemote = NULL;
          
          printf("-M- preparing access to remote file %s\n", name.Data());
	  Char_t tmp[400];
	  sprintf(tmp,name.Data());
          fRemote = rfio_fopen(tmp, "rb");
          if (!(fRemote == NULL))
	    {
              printf("-M- access to remote file\n %s\npossible \n", name.Data());
              if (rfio_fclose(fRemote))
		{
		  Warning("access","-E- closing remote file %s\n", name.Data());
		  perror("    ");
		}
	    }
	  return 0;
    }
  else
    {
      Warning("access","mode value (2nd argument): %i different from only supported 0",mode);
      return 1;
    }
}

Bool_t HRFIORootSource::addFile(Text_t *file) {
  Text_t treeName[]="T";
  TString fname;

  if (file[0] == '/') { // beginning with / ?
    fname=&file[1];
  } else {
    fname=file;
  }
  
  Char_t tmp[800];
  sprintf(tmp,"%s%s/%s",fArchive.Data(),fDirectory.Data(),fname.Data());
  cout << "adding .. " << tmp << endl;
  if (1)//fileExists(tmp)) switched off because CINT does not like rfio_fopen !! to be fixed
    {
      fname=tmp;
      sprintf(tmp,"rfio:/%s",fname.Data());
      
      if (!fInput) { //If chain doesn't already exist
	TRFIOFile *fileTemp;
	TKey *key=0;
	TString title;
	
	fileTemp=new TRFIOFile(tmp); //Obtain tree title
	key=fileTemp->GetKey(treeName);
	HTree * tree = (HTree *)fileTemp->Get("T");
	tree->GetEvent(0);
	
	fEventInFile=(HEvent *)fileTemp->Get("Event");
	
	fCurrentRunId=fEventInFile->getHeader()->getEventRunNumber();
	if (fRefIds.find(fCurrentRunId) != fRefIds.end()) 
	  fCurrentRefId=fRefIds[fCurrentRunId];
	else
	  fCurrentRefId=-1;
	title=key->GetTitle();
	delete key;
	fileTemp->Close();
	fInput=new TChain(treeName,title.Data()); 
	
      }
      fInput->Add(tmp);
    
  } else {
    Warning("addFile","File %s not found",fname.Data());
    return kFALSE;
  }
  return kTRUE;
}

Bool_t HRFIORootSource::setInput(Text_t *fileName,Text_t *archiveName,Text_t *treeName) {
  setArchive(archiveName);
  return setInput(fileName,treeName);
}

Bool_t HRFIORootSource::setInput(Text_t *fileName,Text_t *treeName) {
  //Sets the input file and tree. Opening the corresponding files, it also
  //loads in memory the input event description so the disableCategory() 
  //method can be used.
  if (strcmp(treeName,"T") != 0) return kFALSE;
  return addFile(fileName);
}
Bool_t HRFIORootSource::disableCategory(Cat_t aCat) {
  //Disables the category aCat so it is not read even if it is stored in
  //the input file. This method shouldn't be called after init()
  //Returns kTRUE if the aCat was stored in the input file and has succesfully
  //been disabled, otherwise the return value is kFALSE.
  if (!fEventInFile) return kFALSE;
  return fEventInFile->removeCategory(aCat);
}

inline Int_t HRFIORootSource::getSplitLevel(void) {
  //Returns the split level of the input tree.
  return fSplitLevel;
}

void HRFIORootSource::deactivateBranch(Text_t *branchName) {
  //Deactivates a branch so it is not read. 
  //This method is deprecated, use disableCategory() instead.
  if (fInput) {
    fInput->SetBranchStatus(branchName,kFALSE);
  }
}

TTree *HRFIORootSource::getTree(void) {
  //Returns the input tree.
  return fInput;
}











