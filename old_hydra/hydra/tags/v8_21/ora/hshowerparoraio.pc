//*-- AUTHOR : Ilse Koenig
//*-- Created : 06/07/2000 by I. Koenig

//_HADES_CLASS_DESCRIPTION 
//////////////////////////////////////////////////////////////////////////////
// HShowerParOraIo
//
// Interface class to database Oracle for input/output of parameters needed
// by the SHOWER detector
// (uses the Oracle C/C++ precompiler)
//
//////////////////////////////////////////////////////////////////////////////
using namespace std;
#include "hshowerparoraio.h"
#include "hmessagemgr.h"
#include "hdebug.h"
#include "hades.h"
#include "hruntimedb.h"
#include "hrun.h"
#include "hspectrometer.h"
#include "hdetector.h"
#include "hshowerdetector.h"
#include "hshowersubidpar.h"
#include "hshowercalpar.h"
#include "hshowerunpackparam.h"
#include "hshowerhitfpar.h"
#include "hshowerdigidetpar.h"
#include "hshowergeometry.h"
#include "hgeomcompositevolume.h"
#include "hshowerwire.h"
#include "hgeomoradetversion.h"
#include <iostream>
#include <iomanip>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <TArrayI.h>
#include <TH1.h>
#include <TH2.h>
#include <TAxis.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern


// Oracle communication area
#include <oraca.h>
// SQL Communications Area
#include <sqlca.h>
#include <sqlcpr.h>

ClassImp(HShowerParOraIo)
	
#define SHOWER_SUBID_BASE 300
#define SHOWER_SUBID_MAX  11
#define SHOWER_SUBID_MIN  0

#define SHOWER_MAXMODS 	  18
#define SHOWER_MAXWIRES   89
#define SHOWER_MAXPADS 	  1024
#define SHOWER_MAXSECTORS 6


HShowerParOraIo::HShowerParOraIo(HOraConn* pC) : HDetParOraIo(pC) {
  // constructor
  // sets the name of the I/O class "HShowerParIo"
  // gets the pointer to the connection class
  fName="HShowerParIo";
  m_pShowerIds=0;
  m_pInitModules=new TArrayI(SHOWER_MAXMODS);
  m_nMaxModules = 0;
  m_nRunStart   = 0;
        m_geomVers=0;
}


HShowerParOraIo::~HShowerParOraIo() {
  // destructor
  if (m_pInitModules) delete m_pInitModules;
  if (m_pShowerIds)   delete m_pShowerIds;
        if (m_geomVers)     delete m_geomVers;
}


Bool_t HShowerParOraIo::init(HParSet* pPar,Int_t* set) {
  // calls special read-function for each parameter container
  if ( !startIo() ) return kFALSE; 
  const Text_t* name=pPar->GetName();
  if (strcmp(name,"ShowerCalPar")==0) 
    return read(((HShowerCalPar*)pPar),set);
  if (strcmp(name,"ShowerUnpackParam")==0) 
    return read(((HShowerUnpackParam*)pPar),set);
  if (strcmp(name,"ShowerHitFinderParams")==0) 
    return read(((HShowerHitFPar*)pPar),set);
  if (strcmp(name,"ShowerGeometry")==0) 
    return read(((HShowerGeometry*)pPar),set);
  if (strcmp(name,"ShowerDigiPar")==0) 
    return read(((HShowerDigiDetPar*)pPar),set);
  Error("init","Initialization of %s not possible from Oracle!",name);
  return kFALSE;
}


Bool_t HShowerParOraIo::startIo(void) {
  if ((m_nRunStart=getRunStart())==-1) return kFALSE;
  if (m_pShowerIds==0) {
      m_pShowerIds=new TArrayI(SHOWER_MAXMODS);
  }
  return readIds();  // 
}

Int_t HShowerParOraIo::readIds() {
  // reads the id numbers of all modules defined for actual run
  // and stores them in array m_pShowerIds
  // returns the number of  modules found 
  // returns -1 if nothing is found
  for(Int_t i=0;i<SHOWER_MAXMODS;i++) m_pShowerIds->AddAt(0,i);

  EXEC SQL BEGIN DECLARE SECTION;
  struct {
    int id[SHOWER_MAXMODS];
    int sec[SHOWER_MAXMODS];
    int mod[SHOWER_MAXMODS];
  } mods;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readIds()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL SELECT module_id, sector, module
           INTO :mods
           FROM shower_ana.shw_setup_at_date;
  
  Int_t nMods=sqlca.sqlerrd[2]; 
  HShowerDetector* det=(HShowerDetector*)(gHades->getSetup()->getDetector("Shower"));
  m_nMaxModules=det->getMaxModules();
  Int_t s, m, pos;
  for(Int_t i=0;i<nMods;i++) {
    s=mods.sec[i]-1;
    m=mods.mod[i];
    pos=s*3+m;
    if (det->getModule(s,m)) m_pShowerIds->AddAt(mods.id[i],pos);
  }
  //printIds();
  if(nMods>0){
    return nMods;
  }  
  else return -1;
}

void HShowerParOraIo::printIds() {
  // prints the id numbers of all modules
  if (m_pShowerIds) {
    for(Int_t i=0;i<6;i++) {
      cout<<"Sector: "<<i+1<<"   Shower ids:";
      for(Int_t j=0;j<3;j++) { cout<<" "<<m_pShowerIds->At(i*3+j); }
      cout<<'\n';
    }
    cout<<'\n';
  }
}


Int_t HShowerParOraIo::write(HParSet* pPar) {
  // calls the appropriate write function for the container
  if ( !startIo() ) return kFALSE; 
  const Text_t* name=pPar->GetName();
  if (!strcmp(name,"ShowerCalPar"))
    return writePar((HShowerCalPar*)pPar);
  if (!strcmp(name,"ShowerUnpackParam"))
    return writePar((HShowerUnpackParam*)pPar);
  if (strcmp(name,"ShowerHitFinderParams")==0) 
    return writePar((HShowerHitFPar*)pPar);
  if (strcmp(name,"ShowerGeometry")==0) 
    return writeAlignment((HShowerGeometry*)pPar);
  if (strcmp(name,"ShowerDigiPar")==0) 
    return writePar((HShowerDigiDetPar*)pPar);
  return 0;
}

Int_t HShowerParOraIo::getParVersion(HParSet *pPar, Int_t *versions){
  //Reads the newest version number for parameters *ShowerPar*
  //valid for the curent event file 
  HParOraSet* oraSet=getOraSet(pPar);
  m_nRunStart = getRunStart(pPar);
  if (oraSet->contextId==-1 || m_nRunStart==-1) return -1;
  Int_t contVers=pPar->getInputVersion(inputNumber);
  if ( contVers!=-1 && m_nRunStart>=oraSet->versDate[0] 
          && m_nRunStart<=oraSet->versDate[1] )
       return contVers;
  const Char_t* containerClass=pPar->IsA()->GetName();
  oraSet->clearVersDate();
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int  sec[SHOWER_MAXSECTORS];
      int  vers[SHOWER_MAXSECTORS];
      double since[SHOWER_MAXSECTORS];
      double until[SHOWER_MAXSECTORS];
    } par_vers;
    struct { 
      short sec[SHOWER_MAXSECTORS];
      short vers[SHOWER_MAXSECTORS];
      short since[SHOWER_MAXSECTORS];
      short until[SHOWER_MAXSECTORS];
    } par_vers_ind;
  int context;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("getVersion(HParOraSet*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;  
  context = oraSet->contextId;
  if (strcmp(containerClass,"HShowerCalPar")==0) {
    EXEC SQL SELECT sector,vers_id,
                    hdate.to_ansitime(valid_since),
                    hdate.to_ansitime(valid_until)
             INTO :par_vers INDICATOR :par_vers_ind
             FROM shower_ana.shw_cal_par_vers_at_date
             WHERE context_id = :context;
  }
  else if (strcmp(containerClass,"HShowerUnpackParam")==0){
  EXEC SQL SELECT sector,vers_id,
                    hdate.to_ansitime(valid_since),
                    hdate.to_ansitime(valid_until)
             INTO :par_vers INDICATOR :par_vers_ind
             FROM shower_ana.shw_unp_par_vers_at_date
             WHERE context_id = :context;

  }
  else if  (strcmp(containerClass,"HShowerHitFPar")==0){
  EXEC SQL SELECT sector,vers_id,
                    hdate.to_ansitime(valid_since),
                    hdate.to_ansitime(valid_until)
             INTO :par_vers INDICATOR :par_vers_ind
             FROM shower_ana.shw_hitf_par_vers_at_date
             WHERE context_id = :context;
  }

  else if  (strcmp(containerClass,"HShowerDigiDetPar")==0){
  EXEC SQL SELECT sector,vers_id,
                    hdate.to_ansitime(valid_since),
                    hdate.to_ansitime(valid_until)
             INTO :par_vers INDICATOR :par_vers_ind
             FROM shower_ana.shw_digi_par_vers_at_date
             WHERE context_id = :context;
  
  }
  for(Int_t i=0;i<sqlca.sqlerrd[2];i++) {
    Int_t s = par_vers.sec[i]-1;
    if(par_vers.sec[i]==-1) s=0; //For sector-less parameters
    versions[s] = par_vers.vers[i];
    if (par_vers.since[i]>oraSet->versDate[0]) {
      oraSet->versDate[0]=par_vers.since[i];
    }    
    if (par_vers.until[i]<oraSet->versDate[1]) { 
      oraSet->versDate[1]=par_vers.until[i];
    }
  }

  if (oraSet->versDate[0]>=0) return getActRunId();
  return -1;
}

/* ****************************************************** */
   
Bool_t HShowerParOraIo::read(HShowerCalPar* pPar, Int_t* set) {
  // reads the calibration parameters and fill the ShowerCalPar container
  Int_t contVers=pPar->getInputVersion(inputNumber);
  Int_t versions[SHOWER_MAXSECTORS];
  Int_t version = getPredefVersion(pPar);
  
  if (version==-1) version=getParVersion(pPar,versions);
  if (version==-1) {
    pPar->setInputVersion(-1,inputNumber);  
    return kFALSE;
  }
  if (contVers==version) return kTRUE; //versions are the same/
  if (inputNumber==1) pPar->clear();    
  pPar->setInputVersion(version,inputNumber);
  m_pInitModules->Reset();    
  EXEC SQL BEGIN DECLARE SECTION;
    int id;
    int c_vers;
    struct {
      int p_col[SHOWER_MAXPADS];
      int p_row[SHOWER_MAXPADS];
      float slo[SHOWER_MAXPADS];
      float ofs[SHOWER_MAXPADS];
      float thr[SHOWER_MAXPADS];
      float gai[SHOWER_MAXPADS];
    } cal;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HShowerCalPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE cal_cur CURSOR FOR
    SELECT pad_col, pad_row, slope, offset, threshold, gain
      FROM shower_ana.shw_cal_par_all
      WHERE vers_id = :c_vers AND module = :id;
  HLocation loc;
  loc.setNIndex(4);
  HShowerCalParCell* pCell=0;

  for(Int_t i=0;i<pPar->getNSectors();i++) {
    c_vers=versions[i];
    for(Int_t j=0;j<pPar->getNModules();j++) {
      loc[0] = i;
      loc[1] = j;
      id=10*(i+1)+j;
      Int_t nPads=0;
      if (id>0 && c_vers>0) {
        EXEC SQL OPEN cal_cur;
        EXEC SQL FETCH cal_cur INTO :cal;
        nPads=sqlca.sqlerrd[2];
        if (nPads>0) m_pInitModules->AddAt(id,i*3+j);   
        for(Int_t k=0;k<nPads;k++) {
          loc[2] = cal.p_row[k];
          loc[3] = cal.p_col[k];
          pCell = (HShowerCalParCell*)pPar->getSlot(loc);
          if (pCell) {
            pCell = new(pCell) HShowerCalParCell;
            pCell->setSlope(cal.slo[k]);
            pCell->setOffset(cal.ofs[k]);
            pCell->setThreshold(cal.thr[k]);
            pCell->setGain(cal.gai[k]);
          } else {
            Error("read(HShowerCalPar*,Int_t*)",
                  "slot not found:  %i %i %i %i",loc[0],loc[1],loc[2],loc[3]);
            EXEC SQL CLOSE cal_cur;
            return kFALSE;
          }
        }
      }
    }
  }  
  EXEC SQL CLOSE cal_cur;
  setChanged(pPar);
  return kTRUE;
}

 
Bool_t HShowerParOraIo::read(HShowerUnpackParam* pPar, Int_t* set) {
  
#if DEBUG_LEVEL>2
  gDebuger->enterFunc("HShowerParOraIo::read(HShowerUnpackParam*,Int_t*)");
#endif         
  HShowerSubIdPar *pSubIdPar[12];  
  pPar->defaultInit();
    Int_t contVers=pPar->getInputVersion(inputNumber);
  Int_t versions[SHOWER_MAXSECTORS];
  Int_t version =getPredefVersion(pPar);
  if (version==-1) version=getParVersion(pPar,versions);
  if (version==-1) {
    pPar->setInputVersion(-1,inputNumber);
    return kFALSE;
  }
  if (contVers==version) return kTRUE; //versions are the same/
  pPar->setInputVersion(version,inputNumber);
  m_pInitModules->Reset();
  
  EXEC SQL BEGIN DECLARE SECTION;
    int nVersion;
    int nSec;
    struct {
      int nSubEventID[2]   ;
      int nSectorID[2]     ;
      int nPartOfSector[2] ;
      int nSwap[2]         ;
    } unp_ipc; 
    struct {
      short nSubEventID[2]   ;
      short nSectorID[2]     ;
      short nPartOfSector[2] ;
      short nSwap[2]         ;
    } unp_ipc_ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HShowerUnpPar*,Int_t*)");  
  EXEC SQL WHENEVER NOT FOUND GOTO  not_found;

  EXEC SQL DECLARE unp_cur CURSOR FOR 
       SELECT subevent_id, sector_id, part_of_sector, swap
         FROM shower_ana.shw_unp_par_data
         WHERE vers_id = :nVersion AND sector_id = :nSec ;

  Int_t n =0;
  for (Int_t s=0;s<SHOWER_MAXSECTORS;s++) {
    nSec=s+1;
    m_pInitModules->AddAt(10*nSec,s*3); //3 lines for info only
    m_pInitModules->AddAt(10*nSec+1,s*3+1);
    m_pInitModules->AddAt(10*nSec+2,s*3+2);
    nVersion = versions[s]; 
    EXEC SQL OPEN unp_cur; 
    EXEC SQL FETCH unp_cur INTO :unp_ipc  INDICATOR :unp_ipc_ind;
    for (Int_t r = 0; r<sqlca.sqlerrd[2];r++) {
#if DEBUG_LEVEL>2
      gDebuger->message("Sector= %d",unp_ipc.nSectorID[r]);
      gDebuger->message("SubEventID= %d",unp_ipc.nSubEventID[r]);
      gDebuger->message("Part= %d",unp_ipc.nPartOfSector[r]);
      gDebuger->message("Swap= %d",unp_ipc.nSwap[r]);
#endif        
      pSubIdPar[n] = new HShowerSubIdPar();
      if ( pSubIdPar[n] ) {
        pSubIdPar[n]->setSubID(unp_ipc.nSubEventID[r]);
        pSubIdPar[n]->setPartOfSector(unp_ipc.nPartOfSector[r]);
        pSubIdPar[n]->setSector(unp_ipc.nSectorID[r]-1);
        //Sectors in db start from 1!!!
        pSubIdPar[n]->setSwap(unp_ipc.nSwap[r]);
        pPar->setSubIdPar(pSubIdPar[n],n);
      }
      n++;
    }  
  }
  setChanged(pPar);
#if DEBUG_LEVEL>2
  pPar->print();
  gDebuger->leaveFunc("HShowerParOraIo::read(HShowerUnpackParam*,Int_t*)");
#endif         
  return kTRUE;
not_found:   
  showSqlError("read(HShowerUnpPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return kFALSE;       
}

/* **************************************************** */
Bool_t HShowerParOraIo::read(HShowerHitFPar* pPar, Int_t* set) {
  // Reads the hitfinder  parameters and fill the ShowerHitFinderParams  container  
  Int_t contVers=pPar->getInputVersion(inputNumber);
  Int_t versions[SHOWER_MAXSECTORS];
  Int_t version =getPredefVersion(pPar);

  if (version==-1) version=getParVersion(pPar,versions);
  if (version==-1) {
    pPar->setInputVersion(-1,inputNumber);
    return kFALSE;
  }
  if (contVers==version) return kTRUE; //versions are the same/
  pPar->setInputVersion(version,inputNumber);
  EXEC SQL BEGIN DECLARE SECTION;
    int vers;
    struct {
      int nSectorID [ SHOWER_MAXMODS ];
      int nModuleID [ SHOWER_MAXMODS ];
      int nRowsLow  [ SHOWER_MAXMODS ];
      int nRowsUpp  [ SHOWER_MAXMODS ];
      int nColsLow  [ SHOWER_MAXMODS ];
      int nColsUpp  [ SHOWER_MAXMODS ];
    } hitf_param;
    struct {
      short nSectorID  [ SHOWER_MAXMODS ];
      short nModuleID  [ SHOWER_MAXMODS ];
      short nRowsLow   [ SHOWER_MAXMODS ];
      short nRowsUpp   [ SHOWER_MAXMODS ];
      short nColsLow   [ SHOWER_MAXMODS ];
      short nColsUpp   [ SHOWER_MAXMODS ];
      short nCommentID [ SHOWER_MAXMODS ];
    } hitf_param_ind;
    struct {
    float fit1_par1;
      float fit1_par2;
      float fit1_par3;
      float fit1_par4; //!!!! moze to przemyslec
      float fit2_par1;
      float fit2_par2;
      float fit2_par3;
      float fit2_par4;
    } fit_param;

    struct {
      float gain_post1;//0-post1 1-post2
      float threshold_pos1;//the same
      float gain_post2;//0-post1 1-post2
      float threshold_pos2;//the same
      float tof_max;
      float tof_min;
      float scale_factor;
      int   table_size;
    } criteria;

    struct {
      int sectors;
      int modules;
    } sec_mod;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HShowerHitFPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND GOTO  not_found;

  vers  = versions[0];
  EXEC SQL SELECT gain_post1,threshold_post1,gain_post2,
                  threshold_post2,tof_max,tof_min,
                  cnd_scale_factor,cnd_table_size
           INTO :criteria
           FROM shower_ana.shw_criteria 
           WHERE vers_id = :vers;
  EXEC SQL SELECT fit_1_par1, fit_1_par2, fit_1_par3, fit_1_par4,
                  fit_2_par1, fit_2_par2, fit_2_par3, fit_2_par4
           INTO :fit_param
           FROM shower_ana.shw_fit_param
           WHERE vers_id = :vers;
  EXEC SQL SELECT COUNT( DISTINCT sector_id ), COUNT( DISTINCT MOD(module_ID,10) ) 
           INTO :sec_mod      
           FROM shower_ana.shw_hitf_par_data
          WHERE vers_id = :vers;
  EXEC SQL SELECT sector_id, module_id, rows_lower,
                  rows_upper,cols_lower,cols_upper
           INTO :hitf_param INDICATOR :hitf_param_ind
           FROM shower_ana.shw_hitf_par_data
           WHERE vers_id = :vers; 
  
  pPar->setModules(sec_mod.modules);
  pPar->setSectors(sec_mod.sectors);
  for(Int_t n=0 ; n<sqlca.sqlerrd[2];n++) {
    pPar->setRowBord(hitf_param.nSectorID[n]-1,hitf_param.nModuleID[n],
                     hitf_param.nRowsLow[n],hitf_param.nRowsUpp[n]);
    pPar->setColBord(hitf_param.nSectorID[n]-1,hitf_param.nModuleID[n],
           hitf_param.nColsLow[n],hitf_param.nColsUpp[n]);
  }
  pPar->setGainPost1(criteria.gain_post1);
  pPar->setGainPost2(criteria.gain_post2);
  pPar->setThresholdPost1(criteria.threshold_pos1);
  pPar->setThresholdPost2(criteria.threshold_pos2);
  pPar->setMaxTof(criteria.tof_max);
  pPar->setMinTof(criteria.tof_min);
  pPar->setScaleFactor(criteria.scale_factor);
  pPar->setParamTableSize((Int_t)criteria.scale_factor);
  Float_t *fParTab1; 
  fParTab1 = pPar->getFirstFitParam();
  Float_t *fParTab2;  
  fParTab2 = pPar->getSecondFitParam();
  fParTab1[0] = fit_param.fit1_par1;  
  fParTab1[1] = fit_param.fit1_par2;  
  fParTab1[2] = fit_param.fit1_par3;  
  fParTab1[3] = fit_param.fit1_par4;  
  fParTab2[0] = fit_param.fit2_par1;  
  fParTab2[1] = fit_param.fit2_par2;  
  fParTab2[2] = fit_param.fit2_par3;  
  fParTab2[3] = fit_param.fit2_par4;  

  setChanged(pPar);
  return kTRUE;
  
not_found:
  showSqlError("read(HShowerHitFPar*,Int_t*)");
  rollback();
  pPar->setChanged(kFALSE);
  return kFALSE;
}


Bool_t HShowerParOraIo::read(HShowerDigiDetPar* pPar, Int_t* set) {
#if DEBUG_LEVEL>2
  gDebuger->enterFunc("HShowerParOraIo::read(HShowerDigiDetPar*,Int_t*)");
#endif  
  TH1F *h1=NULL;;
  TH2F *h2=NULL;
  Int_t contVers=pPar->getInputVersion(inputNumber);
  Int_t versions[SHOWER_MAXSECTORS];
  Int_t version =getPredefVersion(pPar);
#if DEBUG_LEVEL>2
  gDebuger->message("PredefVersion is :%d",version);
#endif  
  if (version==-1) version=getParVersion(pPar,versions);
  if (version==-1) {
    pPar->setInputVersion(-1,inputNumber);
    return kFALSE;
  }
  if (contVers==version) return kTRUE; //versions are the same/
#if DEBUG_LEVEL>2
  gDebuger->enterFunc("HShowerParOraIo::read(HShowerDigiDetPar*,Int_t*)");
  gDebuger->message("Selected version is :%d",version);
#endif  
  pPar->setInputVersion(version,inputNumber);
  EXEC SQL BEGIN DECLARE SECTION;
    int nVers;
    struct {
      int   vers;
      float thick_det;
      int   matrix_range;
      float box_size;
      float charge_slope;
      float plane_dist;
      float pad_range;
      float pad_threshold;
      float update_pad_threshold;
      float master_offset; 
      int   n_bin_e;
      float min_e;
      float max_e;
      int   n_bin_x_s;
      int   n_bin_y_s;
      float min_x_s;
      float max_x_s;
      float min_y_s;
      float max_y_s;
    }digi;
    int vers_id[100];
    int bin_id[100];
    double bin_content[100];
    int vers_sum[15000];
    int bin_id_x[15000];
    int bin_id_y[15000];
    double bin_content_s[15000];
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("read(HShowerDigiPar*,Int_t*)");
  EXEC SQL WHENEVER NOT FOUND GOTO  not_found;

  nVers = versions[0]; //no sector dependency

  EXEC SQL SELECT * INTO :digi 
           FROM shower_ana.shw_digi_par_data 
           WHERE vers_id = :nVers;
  if(sqlca.sqlerrd[2]!=1) return kFALSE;
  pPar->setThickDet(digi.thick_det);
  pPar->setBoxSize(digi.box_size);
  pPar->setChargeSlope(digi.charge_slope);
  pPar->setPlaneDist(digi.plane_dist);
  pPar->setPadRange((Int_t)digi.pad_range);
  pPar->setPadThreshold(digi.pad_threshold);
  pPar->setUpdatePadThreshold(digi.update_pad_threshold);
  pPar->setMasterOffset(digi.master_offset);
  pPar->setChargeMatrix(digi.matrix_range);  
  pPar->initChargeMatrix();
  EXEC SQL SELECT vers_id, bin_id, bin_content 
           INTO :vers_id, :bin_id, :bin_content 
           FROM  shower_ana.shw_eff_hist
           WHERE vers_id = :nVers;
  h1 = (TH1F*)pPar->getEfficiencyHist();  
  if(h1) {  
    cout<<"Histogram exists, will be overwritten"<<endl;
    h1->SetBins(digi.n_bin_e,digi.min_e,digi.max_e);
  }
  else
    h1 = new TH1F("hEfficiency","hEfficiency",digi.n_bin_e,digi.min_e,digi.max_e);
  for(Int_t i=0; i<sqlca.sqlerrd[2];i++){
    h1->SetBinContent(bin_id[i],bin_content[i]);
  }  
  h1->SetDirectory(0);
  pPar->setEfficiencyHist(h1);
  EXEC SQL SELECT vers_id,  bin_id_x, bin_id_y, bin_content
           INTO :vers_sum,:bin_id_x,:bin_id_y, :bin_content_s
           FROM  shower_ana.shw_sum_beta_hist
           WHERE vers_id = :nVers;
  
  h2 = (TH2F*)pPar->getQvBHist();
  if(h2){ 
    cout<<"Histogram exists, will be overwritten"<<endl;
    h2->SetBins(digi.n_bin_x_s,digi.min_x_s,digi.max_x_s,
                digi.n_bin_y_s,digi.min_y_s,digi.max_y_s);
  }
  else
    h2 = new TH2F("h2SumVerBetaFit","h2SumVerBetaFit",digi.n_bin_x_s,digi.min_x_s,digi.max_x_s,
                  digi.n_bin_y_s,digi.min_y_s,digi.max_y_s);
  for(Int_t i=0; i<sqlca.sqlerrd[2];i++){
    h2->SetBinContent(bin_id_x[i],bin_id_y[i],bin_content_s[i]);
  }   
  h2->SetDirectory(0);
  pPar->setQvBHist(h2);
  pPar->initSumVerBetaHistograms();
  setChanged(pPar);
#if DEBUG_LEVEL>2
  pPar->print();
  gDebuger->leaveFunc("HShowerParOraIo::read(HShowerDigiDetPar*,Int_t*)");
#endif  
  return kTRUE;

not_found:
  showSqlError("read(HShowerDigiDetPar*,Int_t*)");
  rollback();
  pPar->setChanged(kFALSE);
  return kFALSE;
}

/* **************************************************** */

Bool_t HShowerParOraIo::read(HShowerGeometry* pPar, Int_t *set){
  Bool_t allFound=kTRUE;
  Int_t detId=-1;
  if (!m_geomVers) {
    detId=getDetectorId(pPar->getDetectorName());
    m_geomVers=new HGeomOraDetVersion(pPar->getDetectorName(),detId);
  } else {
    detId=m_geomVers->getDetectorId();
  }
  if (detId<=0) {
    allFound=kFALSE;
    delete m_geomVers;
    m_geomVers=0;
  }
  if (detId>0&&pPar->isFirstInitialization()) {
    if (!readModGeomNames(pPar,set)) {
      allFound=kFALSE;
      pPar->clear();
    } else addGeomOraSet(pPar);
  }  
  if (allFound) allFound=readDetectorGeometry(pPar,set,m_geomVers);
  if (allFound&&pPar->hasChanged()) allFound=fillGeom(pPar);
  return allFound;    
}


/* **************************************************** */

Bool_t HShowerParOraIo::readModGeomNames(HShowerGeometry* pPar,Int_t* set) {
  EXEC SQL BEGIN DECLARE SECTION;
    struct {
      int id[SHOWER_MAXMODS];
      int sec[SHOWER_MAXMODS];
      int mod[SHOWER_MAXMODS];
      varchar oname[SHOWER_MAXMODS][9];
      varchar component[SHOWER_MAXMODS][9];
    } mods;
    struct {
      short id_Ind[SHOWER_MAXMODS];
      short sec_Ind[SHOWER_MAXMODS];
      short mod_Ind[SHOWER_MAXMODS];
      short oname_Ind[SHOWER_MAXMODS];
      short comp_Ind[SHOWER_MAXMODS];
    } mods_Ind;
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO showSqlError("readModGeomNames()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;

  EXEC SQL SELECT module_id, sector, module, geom_obj_name, component_name
           INTO :mods INDICATOR :mods_Ind
           FROM shower_ana.shw_setup_at_date;
  Int_t nMods=sqlca.sqlerrd[2];
  Int_t pos, s, m;
  Char_t ref[10];
  m_pInitModules->Reset();
  for(Int_t i=0;i<nMods;i++) {
    s=mods.sec[i]-1;
    m=mods.mod[i];
    HModGeomPar* pMod=pPar->getModule(s,m);
    pos=s*m_nMaxModules + m;
    if (pMod && set[pos]) {
      if (mods_Ind.oname_Ind[i]!=-1) {
        mods.oname[i].arr[mods.oname[i].len]='\0';
        pMod->SetName((Char_t*)(mods.oname[i].arr));
        m_pInitModules->AddAt(pos+1,pos);
        strcpy(ref,(Char_t*)(mods.oname[i].arr));
        ref[4]='1'; // reference module in sector 1
                    // not yet introduced in database
        pMod->setRefName(ref);
        Int_t mr=pPar->getModNumInMod(ref);
        HGeomCompositeVolume* refMod=pPar->getRefVolume(mr);
        if (refMod==0) {
          refMod=new HGeomCompositeVolume(pPar->getNumComponents());
          refMod->SetName(ref);
          pPar->addRefVolume(refMod,mr);
        }
        pMod->setVolume(refMod);
        //In Shower case this is  a wires plane (3)
        if (mods_Ind.comp_Ind[i]!=-1) {
          HGeomVolume* volu=refMod->getComponent(0);
          mods.component[i].arr[mods.component[i].len]='\0';
          volu->SetName((Char_t*)(mods.component[i].arr));          
        }
      }
    }
  }
  
  Bool_t allFound=kTRUE;
  Int_t n=SHOWER_MAXSECTORS*m_nMaxModules;
  for(Int_t i=0;i<n;i++) {
    if (set[i]>0 && m_pInitModules->At(i)==0) allFound=kFALSE;
  }
  return allFound;
}
  

/* ******************************** */
Bool_t HShowerParOraIo::fillGeom(HShowerGeometry* pPar){
  //Function for calculating the module centers and tranformation used in analysis
  //(corresponding to the PAD_FIBREs)
  //For more info see documentation:
  //http://hades.if.uj.edu.pl/docs/shower/geometry
  HGeomVector vm[3] = { HGeomVector(0.000 , 0.00 ,  -4.0), 
                        HGeomVector(0.000 , 0.00 ,  67.6), 
                        HGeomVector(0.000 , 0.00 , 134.9)};
  pPar->m_nSectors = pPar->getMaxSectors();
  pPar->m_nModules = pPar->getMaxModules();
  pPar->m_nRows = 32; //! 
  pPar->m_nColumns = 32;//!
  pPar->m_nLab = 1;//!
  Int_t angle[6] = {0,300,240,180,120,60};
  for (Int_t s=0;s<pPar->getMaxSectors();s++){
    pPar->sectors[s].reset();
    pPar->sectors[s].setAngleRot(angle[s]);
    pPar->sectors[s].transform.setRotMatrix(
                     pPar->getModule(s,0)->getLabTransform().getRotMatrix());
    pPar->sectors[s].transform.setTransVector(
                     pPar->getModule(s,0)->getLabTransform().getTransVector());
    for(Int_t m=0;m<pPar->getMaxModules();m++){
      HModGeomPar* pMod = pPar->getModule(s,m);
      HShowerModuleGeom *pModGeom = new HShowerModuleGeom;
      pModGeom->setModuleID(m);
      HGeomRotation rotM = pMod->getLabTransform().getRotMatrix();
      pModGeom->transform.setRotMatrix(pMod->getLabTransform().getRotMatrix());
      HGeomVector v = pMod->getLabTransform().getTransVector();
      HGeomVector v_mod = rotM*vm[m]+v;
      //set new vector for modules;
      pModGeom->transform.setTransVector(v_mod);
      pPar->sectors[s].addModule(pModGeom);
    }  
  }
  HGeomVector *points[4];
  HShowerFrameCorner *pFC;

  for(Int_t m = 0; m < 3; m++) {
    HGeomCompositeVolume* refMod=pPar->getRefVolume(m);
    HGeomVolume *comp = refMod->getComponent(0);//only one comp; wires plane
    points[0] = comp->getPoint(3);//geant coordinate system is left-handed!! 
    points[1] = comp->getPoint(2);//
    points[2] = comp->getPoint(1);//
    points[3] = comp->getPoint(0);//
    pPar->frames[m].reset();
    pPar->frames[m].setModuleID(m);
    for (Int_t i=0;i<4;i++){
      pFC = new HShowerFrameCorner;
      pFC->setX(points[i]->getX()*0.1);
      pFC->setY(points[i]->getY()*0.1);
      if(i==0 || i==3) pFC->setFlagArea(1);
      else pFC->setFlagArea(0);
      pPar->frames[m].addCorner(pFC);
    }
  }
  if(!readGeom(pPar)) return kFALSE;
  pPar->attachTables(); 
  return kTRUE;
}


Bool_t HShowerParOraIo::readGeom(HShowerGeometry* pPar){
  //Function for reading information about pads, wires etc.
  //which is not accesible via HDetGeomPar interface
  EXEC SQL BEGIN DECLARE SECTION;
    struct  {
      int id[267]; //3*89 wires
      int wire_id[267];
      float wire_coord[267];
      float distance[267];
      int   module_type_id[267];
    }wire;
    struct {
      int id[SHOWER_MAXPADS];
      int module_type_id[SHOWER_MAXPADS];
      float x_ld[SHOWER_MAXPADS];
      float x_lu[SHOWER_MAXPADS];
      float x_rd[SHOWER_MAXPADS];
      float x_ru[SHOWER_MAXPADS];
      float y_ld[SHOWER_MAXPADS];
      float y_lu[SHOWER_MAXPADS];
      float y_rd[SHOWER_MAXPADS];
      float y_ru[SHOWER_MAXPADS];
      int pad_flag[SHOWER_MAXPADS];
      int linked_to[SHOWER_MAXPADS] ;
    }data;
    int mod_id;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO showSqlError("readWires()");
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
  EXEC SQL DECLARE pad_cur CURSOR FOR
            SELECT id,module_type_id,
                   X_LD,Y_LD, X_LU, Y_LU, X_RD,Y_RD, X_RU,Y_RU,PAD_FLAG,LINKED_TO  
            FROM shower_ana.shw_pad_geom
            WHERE module_type_id= :mod_id;
  Int_t l;
  for(Int_t m=0;m<3;m++){  //3 modules 0,1,2
    mod_id=m;
    EXEC SQL OPEN pad_cur;
    EXEC SQL FETCH pad_cur INTO :data;
    Int_t nPads = sqlca.sqlerrd[2];
    pPar->pads[m].createPads(32,32);
    pPar->pads[m].setModuleID(m);
    HShowerPad* p = new HShowerPad;
    for(Int_t i=0; i <nPads; i++) {
      p->setPadNr((data.id[i]-1)-(m*1024));
      pPar->pads[m].setPad(p, (data.id[i]-1)-(m*1024));
    }
    delete p;
    for(Int_t n=0; n<nPads;n++){
      HShowerPad* pad = pPar->pads[m].getPad((data.id[n]-1)-(m*1024));
      if(pad){
        pad->fXld = data.x_ld[n];
        pad->fYld = data.x_lu[n];
        pad->fXlu = data.x_rd[n];
        pad->fYlu = data.x_ru[n];
        pad->fXrd = data.y_ld[n];
        pad->fYrd = data.y_lu[n];
        pad->fXru = data.y_rd[n];
        pad->fYru = data.y_ru[n];
        pPar->pads[m].setFrame(pPar->getFrame(m));
        //Calculate pad flag (0,1,2)  
        HShowerFrame* phFrame = pPar->pads[m].getFrame();
        if ((!phFrame->isOut(pad->fXld, pad->fYld)) &&
            (!phFrame->isOut(pad->fXlu, pad->fYlu)) &&
            (!phFrame->isOut(pad->fXru, pad->fYru)) &&
            (!phFrame  ->isOut(pad->fXrd, pad->fYrd))) {
          pad->setPadFlag(1);
        } else if (!phFrame->isOut(pad->fXld, pad->fYld) ||
                   !phFrame->isOut(pad->fXlu, pad->fYlu) ||
                   !phFrame->isOut(pad->fXru, pad->fYru) ||
                   !phFrame->isOut(pad->fXrd, pad->fYrd)) {
          pad->setPadFlag(2);
        } else {
          pad->setPadFlag(0);
        }

        pad->setLinkedNr(data.pad_flag[n]);
        if (pad->getLinkedNr()) {
          if (pad->linkPad) delete [] pad->linkPad;
          pad->linkPad = new HShowerPad*[pad->getLinkedNr()];
          for (Int_t k=0; k<pad->getLinkedNr(); k++) {
            l = data.linked_to[n];
            pad->linkPad[k] = pPar->pads[m].getPad(l);
          }
        }
      }
    }
  }
  EXEC SQL CLOSE pad_cur;
  EXEC SQL SELECT id,wire_id,wire_coord,distance,module_type_id
           INTO :wire
           FROM shower_ana.shw_wire
           ORDER BY id;
  HShowerWire* pWire;
  Int_t nWires = sqlca.sqlerrd[2];
  pPar->wires[0].reset();
  pPar->wires[1].reset();
  pPar->wires[2].reset();

  for(Int_t w=0;w<nWires;w++){
    pPar->wires[wire.module_type_id[w]].setModuleID(wire.module_type_id[w]);
    pWire = new HShowerWire;
    pWire->setNrWire(wire.wire_id[w]);
    pWire->setYWire(wire.wire_coord[w]);
    pPar->wires[wire.module_type_id[w]].setDistWire(wire.distance[w]);
    pPar->wires[wire.module_type_id[w]].addWire(pWire);
  }
  return kTRUE;
}                  
/* **************************************************** */

Int_t HShowerParOraIo::writePar(HShowerCalPar* pPar) {
  // creates a new version and writes the calibration parameters to Oracl
  if(!pPar) return -1;
  Int_t version=createVers(pPar);
  if (version==-1) return -1;
  EXEC SQL BEGIN DECLARE SECTION;
    int id[SHOWER_MAXPADS];
    int vers[SHOWER_MAXPADS];
    float slo[SHOWER_MAXPADS];
    float ofs[SHOWER_MAXPADS];
    float trh[SHOWER_MAXPADS];
    float gai[SHOWER_MAXPADS];
    int rows_to_insert;
  EXEC SQL END DECLARE SECTION;

  HLocation loc;
  loc.set(4,0,0,0,0);
  HShowerCalParCell* pCell=0;
  Float_t cs=0, co=0,cg=0,ct=0;
  for(Int_t s=0;s<pPar->getNSectors();s++){ 
    for(Int_t m=0;m<pPar->getNModules();m++){ 
      Int_t nCell=-1;
      Int_t sId=(s+1)*10+m;
      if (sId>0){ 
        loc[0] = s;
        loc[1] = m;
        for(Int_t r=0;r<pPar->getNRows();r++) {
          loc[2]=r;
          for(Int_t c=0;c<pPar->getNColumns();c++){ 
            loc[3]=c;
            pCell = (HShowerCalParCell*)pPar->getObject(loc);
            if (pCell) {
              cs=pCell->getSlope();
              co=pCell->getOffset();
              ct=pCell->getThreshold();
              cg=pCell->getGain();
              if (co!=0 || cs!=1) { // only non-default values
                nCell++;
                if (nCell==SHOWER_MAXPADS) {
                  Error("writePar(HShowerCalPar*)","\n Number of Pads > 1024\n");
                  rollback();
                  return -1;
                }
                id[nCell]=sId*10000 + r*100 + c;
                vers[nCell]=version;
                slo[nCell]=cs;
                ofs[nCell]=co;
                trh[nCell]=ct;
                gai[nCell]=cg;
              }
            }
          }
        }
      }
      if (nCell==-1) continue;
      rows_to_insert=nCell+1;
      EXEC SQL WHENEVER SQLERROR GOTO not_found;
      EXEC SQL WHENEVER NOT FOUND GOTO not_found;
      EXEC SQL FOR :rows_to_insert
        INSERT INTO shower_ana.shw_cal_par_data
            (pad_id, vers_id, slope, offset,threshold,gain )
            VALUES (:id, :vers, :slo, :ofs, :trh,:gai);
    }
  }
  cout<<"********    Calibration parameters written to Oracle ***********\n";
  cout<<"****************************************************************\n";
  commit();
  pPar->setChanged(kFALSE);
  return version;
not_found:
  showSqlError("writePar(HShowerCalPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;
}


Int_t HShowerParOraIo::writePar(HShowerUnpackParam* pPar) {
  //Write unpacker parameters to the Oracle 
  if(!pPar) return -1;
  HShowerSubIdPar *pSubIdPar[12];
  Int_t nSubId[12];

  Int_t version = createVers(pPar);
  if (version==-1) return -1;  
  EXEC SQL BEGIN  DECLARE SECTION;
    int nVersion      [ SHOWER_SUBID_MAX + 1 ];
    int nSectorID     [ SHOWER_SUBID_MAX + 1 ];
    int nSubEventID   [ SHOWER_SUBID_MAX + 1 ];
    int nPartOfSector [ SHOWER_SUBID_MAX + 1 ];
    int nSwap      [ SHOWER_SUBID_MAX + 1 ];
  EXEC SQL END DECLARE SECTION;
  
  for(Int_t n= SHOWER_SUBID_MIN ; n<=SHOWER_SUBID_MAX ;n++){
    nVersion[n]     = version; //the same for all 
    nSubId[n]        = SHOWER_SUBID_BASE + n;
    pSubIdPar[n]     = pPar->getSubIdPar(nSubId[n]);
    nSectorID[n]     = pSubIdPar[n]->getSector()+1; // Sector number in db starts from 1!!! 
    nSubEventID[n]   = pSubIdPar[n]->getSubID();  
    nPartOfSector[n] = pSubIdPar[n]->getPartOfSector();
    nSwap[n]     = pSubIdPar[n]->getSwap();
  }
    
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;  
  EXEC SQL INSERT INTO shower_ana.shw_unp_par_data 
               (vers_id, subevent_id, sector_id, part_of_sector, swap)
               VALUES (:nVersion, :nSubEventID, :nSectorID, :nPartOfSector, :nSwap);    
  cout<<"*********  Unpacker  parameters written to Oracle  *************\n";
  cout<<"****************************************************************\n";
  commit();
  pPar->setChanged(kFALSE);
  return version;
  
not_found:
  showSqlError("writePar(HShowerUnpackPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;     
}

Int_t HShowerParOraIo::writePar(HShowerHitFPar* pPar) {
  //Write hitfinder parameters to the Oracle 
  if(!pPar) return -1;
  Int_t version = createVers(pPar);
  if(version==-1) return -1;  
  EXEC SQL BEGIN DECLARE SECTION;
    int nVersion   [ SHOWER_MAXMODS ];
    int nSectorID  [ SHOWER_MAXMODS ];
    int nModuleID  [ SHOWER_MAXMODS ];
    int nRowsLow   [ SHOWER_MAXMODS ];
    int nRowsUpp   [ SHOWER_MAXMODS ];
    int nColsLow   [ SHOWER_MAXMODS ];
    int nColsUpp   [ SHOWER_MAXMODS ];
    int nCommentID [ SHOWER_MAXMODS ];
    int   vers;
    float fit1_par1;
    float fit1_par2;
    float fit1_par3;
    float fit1_par4;
    float fit2_par1;
    float fit2_par2;
    float fit2_par3;
    float fit2_par4;
    float gain_post1;//0-post1 1-post2
    float gain_post2;//0-post1 1-post2
    float threshold_pos1;//the same
    float threshold_pos2;//the same
    float tof_max;
    float tof_min;
    float scale_factor;
    int   table_size;  
  EXEC SQL END DECLARE SECTION;
  Float_t *fit_par1 = pPar->getFirstFitParam();
  Float_t *fit_par2 = pPar->getSecondFitParam();
  if(fit_par1){
    fit1_par1 = fit_par1[0];
    fit1_par2 = fit_par1[1];
    fit1_par3 = fit_par1[2];
    fit1_par4 = fit_par1[3];
   } else {
    fit1_par1 =0;
    fit1_par2 =0;
    fit1_par3 =0;
    fit1_par4 =0;
  }
  if(fit_par2){
    fit2_par1 = fit_par2[0];
    fit2_par2 = fit_par2[1];
    fit2_par3 = fit_par2[2];
    fit2_par4 = fit_par2[3];
  } else {
    fit2_par1 =0;
    fit2_par2 =0;
    fit2_par3 =0;
    fit2_par4 =0;
  }

  gain_post1 = pPar->getGainPost1();
  gain_post2 = pPar->getGainPost2();
  threshold_pos1 = pPar->getThresholdPost1();
  threshold_pos2 = pPar->getThresholdPost2();
  tof_min = pPar->getMinTof();
  tof_max = pPar->getMaxTof();
  scale_factor  = pPar->getScaleFactor();
  table_size    = pPar->getParamTableSize();

  //Fill hitF_par_data table  
  Int_t n=0;
  vers = version;
  Int_t nSectors = pPar->getSectors();
  Int_t nModules = pPar->getModules();
  for(Int_t i=0; i< nSectors; i++){
    for(Int_t ii=0; ii<nModules;ii++){
      nVersion[n]  = version;
      nSectorID[n] =i+1; //1-6
      nModuleID[n] =10*(i+1) + ii; //  
      pPar->getRowBord(i,ii,&nRowsLow[n],&nRowsUpp[n]);
      pPar->getColBord(i,ii,&nColsLow[n],&nColsUpp[n]);
      nCommentID[n]=4;
      n++;
    }
  }
  EXEC SQL INSERT INTO shower_ana.shw_fit_param
               ( vers_id, fit_1_par1, fit_1_par2, fit_1_par3, fit_1_par4,
                 fit_2_par1, fit_2_par2, fit_2_par3, fit_2_par4 )
               VALUES
               ( :vers, :fit1_par1, :fit1_par2, :fit1_par3, :fit1_par4, 
                 :fit2_par1, :fit2_par2, :fit2_par3, :fit2_par4); 
  
  EXEC SQL INSERT INTO shower_ana.shw_criteria
               ( vers_id, gain_post1,threshold_post1,
                 gain_post2, threshold_post2,tof_max,tof_min,
                 cnd_scale_factor,cnd_table_size)
               VALUES
               ( :vers,:gain_post1, :threshold_pos1, :gain_post2, 
                 :threshold_pos2, :tof_max, :tof_min, :scale_factor,
                 :table_size );

  EXEC SQL INSERT INTO shower_ana.shw_hitf_par_data 
               ( vers_id, sector_id, module_id, rows_lower, 
                 rows_upper,cols_lower,cols_upper)
               VALUES
               ( :nVersion,:nSectorID,:nModuleID,:nRowsLow,
                 :nRowsUpp,:nColsLow,:nColsUpp);    
  commit();
  //pPar->print();
  pPar->setChanged(kFALSE);
  cout<<"************  HitFinder parameters written to Oracle ***********\n";
  cout<<"****************************************************************\n";

  return version;
  
not_found:
  showSqlError("writePar(HShowerHitFPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;      
}


Int_t HShowerParOraIo::writePar(HShowerDigiDetPar* pPar) {
  // creates a new version and writes the calibration parameters to Oracl
  if(!pPar) return -1;
  Int_t version=createVers(pPar);
  if (version==-1) return -1;
  Int_t n=0;
  EXEC SQL BEGIN  DECLARE SECTION;
    struct{    
      int vers;
      float thick_det;
      int matrix_range;
      float box_size; 
      float  charge_slope;
      float plane_dist;    
      float pad_range;   
      float pad_threshold;
      float update_pad_threshold;
      float master_offset;        
      int n_bin_e;             
      float min_e;            
      float max_e;           
      int n_bin_x_s;        
      int n_bin_y_s;       
      float  min_x_s;     
      float max_x_s;     
      float min_y_s;     
      float max_y_s;
    } dg;
  EXEC SQL END DECLARE SECTION;

  dg.vers = version;
  dg.thick_det = pPar->getThickDet();
  dg.matrix_range = pPar->getMatrixRange();
  dg.box_size = pPar->getBoxSize();
  dg.charge_slope = pPar->getChargeSlope();
  dg.plane_dist = pPar-> getPlaneDist();
  dg.pad_range = pPar->getPadRange();
  dg.pad_threshold = pPar->getPadThreshold();
  dg.update_pad_threshold = pPar->getUpdatePadThreshold();
  dg.master_offset = pPar->getMasterOffset();

  dg.n_bin_e=1;  
  dg.min_e=1;  
  dg.max_e=1;  
  dg.n_bin_x_s=1;  
  dg.n_bin_y_s=1;  
  dg.min_x_s=1;  
  dg.max_x_s=1;  
  dg.min_y_s=1;  
    dg.max_y_s=1;

  TH1F *pEffH = (TH1F*)pPar->getEfficiencyHist();
  TH2F *pSumH = (TH2F*)pPar->getQvBHist();
   
  EXEC SQL BEGIN DECLARE SECTION;
    int vers[100];
    int bin_id[100];
    double bin_content[100];
    int vers_sum[15000];
    int bin_id_x[15000];
    int bin_id_y[15000];
    double bin_content_s[15000];
  EXEC SQL END DECLARE SECTION;

  if(pEffH){
    dg.n_bin_e  = pEffH->GetNbinsX();
    TAxis *axis = pEffH->GetXaxis();
    dg.max_e = axis->GetXmax();
    dg.min_e = axis->GetXmin();
    for (Int_t i=1; i<=dg.n_bin_e;i++){
      vers[i-1] = version;
      bin_id[i-1] = i;
      bin_content[i-1] = pEffH->GetBinContent(i);
    }
  }  
  if(pSumH){
    dg.n_bin_x_s = pSumH->GetNbinsX();
    dg.n_bin_y_s = pSumH->GetNbinsY();
    TAxis *axisX = pSumH->GetXaxis();
    TAxis *axisY = pSumH->GetYaxis();
    dg.max_x_s = axisX->GetXmax();
    dg.min_x_s = axisX->GetXmin();
    dg.max_y_s = axisY->GetXmax();
    dg.min_y_s = axisY->GetXmin();
    for (Int_t i=1; i<=dg.n_bin_x_s;i++){
      for(Int_t ii=1;ii<=dg.n_bin_y_s;ii++){
        vers_sum[n]=version;
        bin_id_x[n] = i;
        bin_id_y[n] = ii;
        bin_content_s[n] = pSumH->GetBinContent(i,ii);
        n++;
      }
    }
  }
  EXEC SQL INSERT INTO shower_ana.shw_digi_par_data 
               ( vers_id, thick_det,matrix_range,box_size,charge_slope,
                 plane_dist, pad_range,pad_threshold,update_pad_threshold,
                 master_offset,n_bin_e,min_e, max_e,n_bin_x_s,n_bin_y_s,min_x_s,
                 min_y_s,max_y_s, max_x_s)
               values
               ( :dg.vers,:dg.thick_det,:dg.matrix_range,:dg.box_size,
                 :dg.charge_slope,:dg.plane_dist,:dg.pad_range,:dg.pad_threshold,
                 :dg.update_pad_threshold,:dg.master_offset,:dg.n_bin_e,
                 :dg.min_e,:dg.max_e,:dg.n_bin_x_s,:dg.n_bin_y_s,:dg.min_x_s,
                 :dg.min_y_s,:dg.max_y_s, :dg.max_x_s );
  EXEC SQL INSERT INTO shower_ana.shw_eff_hist
               (vers_id, bin_id, bin_content)
               VALUES (:vers,:bin_id,:bin_content);
  EXEC SQL INSERT INTO shower_ana.shw_sum_beta_hist
               (vers_id, bin_id_x, bin_id_y,bin_content)
               VALUES (:vers_sum,:bin_id_x,:bin_id_y,:bin_content_s);
  commit();
  pPar->setChanged(kFALSE);
  cout<<"********* Digitization  parameters written to Oracle ***********\n";
  cout<<"****************************************************************\n";
  return version;

not_found:
  showSqlError("writePar(HShowerHitFPar*)");
  rollback();
  pPar->setChanged(kFALSE);
  return -1;
}


void HShowerParOraIo::printInfo(const Text_t* msg) {
  // prints the modules initialized from Oracle
  // will later go to the log file
  Bool_t first=kTRUE;
  cout<<'\n';
  for(Int_t i=0;i<SHOWER_MAXMODS;i++) {
    if (m_pInitModules->At(i)) {
      if (first) {
        cout<<msg<<endl;
        first=kFALSE;
      }
      cout<<(m_pInitModules->At(i))<<" ";
    }
  }
  cout<<'\n';
}


Int_t HShowerParOraIo::createVers(HParSet *pPar){

  cout<<"\n------------------  "<<pPar->GetName()<<"   ------------------\n";
  cout<<"Author"<<pPar->getAuthor()<<endl;
  if (strlen(pPar->getAuthor())==0) {
    Error("createVers(HParSet*)",
          "\nAuthor of parameters not defined, please set it!");
    return -1;
  }
  if (strlen(pPar->getDescription())==0) {
    Error("createVers(HParSet*)",
          "\ndescricption of parameters not definedi, please set it!");
    return -1;
  }

  EXEC SQL BEGIN DECLARE SECTION;
    int   vers=-1;
    int   context;
    int   run;
    char* creator;
    char* descript;
  EXEC SQL END DECLARE SECTION;
  context = getContextId(pPar->IsA()->GetName(),pPar->getParamContext());
  if (context==-1) return -1;
  run=getActRunId();
  creator  = (Char_t*)pPar->getAuthor();
  descript = (Char_t*)pPar->getDescription();
  EXEC SQL WHENEVER SQLERROR GOTO not_found;
  EXEC SQL WHENEVER NOT FOUND GOTO not_found;
  const Char_t* contName=pPar->IsA()->GetName();
  
  if (strcmp(contName,"HShowerCalPar")==0) {
    EXEC SQL EXECUTE
      BEGIN
        SELECT shower_ana.shower_util.next_version INTO :vers FROM DUAL;
        INSERT INTO shower_ana.shw_cal_par_vers
                     (vers_id, orig_context_id, run_id, author, description)
               VALUES (:vers, :context, :run, :creator, :descript);
      END;
    END-EXEC;
    cout<<"Oracle version for ShowerCalPar created:  "<<vers<<endl;
  }
  else if (strcmp(contName,"HShowerUnpackParam")==0) {
    EXEC SQL EXECUTE
      BEGIN
        SELECT shower_ana.shower_util.next_version INTO :vers FROM DUAL;
        INSERT INTO shower_ana.shw_unp_par_vers
                   (vers_id, orig_context_id, run_id, author, description)
               VALUES (:vers, :context, :run, :creator, :descript);
      END; 
    END-EXEC;
    cout<<"Oracle version for ShowerUnpackParam  created:  "<<vers<<endl;

  }
  else if  (strcmp(contName,"HShowerHitFPar")==0) {
    EXEC SQL EXECUTE
      BEGIN
        SELECT shower_ana.shower_util.next_version INTO :vers FROM DUAL;
        INSERT INTO shower_ana.shw_hitf_par_vers
                    (vers_id, orig_context_id, run_id, author, description)
               VALUES (:vers, :context, :run, :creator, :descript);
      END; 
    END-EXEC;
    cout<<"Oracle version for ShowerHitFinderParam  created:  "<<vers<<endl;
  }
  else if  (strcmp(contName,"HShowerDigiDetPar")==0) {
    EXEC SQL EXECUTE
      BEGIN
        SELECT shower_ana.shower_util.next_version INTO :vers FROM DUAL;
        INSERT INTO shower_ana.shw_digi_par_vers
                    (vers_id, orig_context_id, run_id, author, description)
               VALUES (:vers, :context, :run, :creator, :descript);
      END;
    END-EXEC;
    cout<<"Oracle version for ShowerDigiPar  created:  "<<vers<<endl;
  }
  else {
    Error("createVers(HParSet *pPar)","I don't know such container:%s",contName);
  }

  return vers;
not_found:
  showSqlError("createVers(HParSet*)");
  return -1;
} 
